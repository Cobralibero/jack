diff --git a/libavformat/dashdec.c b/libavformat/dashdec.c
index f63f1ff..b1edca0 100644
--- a/libavformat/dashdec.c
+++ b/libavformat/dashdec.c
@@ -1,7 +1,6 @@
 /*
  * Dynamic Adaptive Streaming over HTTP demux
  * Copyright (c) 2017 samsamsam@o2.pl based on HLS demux
- * Copyright (c) 2017 Steven Liu
  *
  * This file is part of FFmpeg.
  *
@@ -19,61 +18,169 @@
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
-#include <libxml/parser.h>
+ 
+ /* Code prepared for ffmpeg 2.8.9 and then ported to ffmpeg 3.3
+  * At now it allow to play one selected representation for audio and video components.
+  * 
+  */
+
+/**
+ * @file
+ */
+#include "libavutil/avstring.h"
+#include "libavutil/avassert.h"
 #include "libavutil/intreadwrite.h"
+#include "libavutil/mathematics.h"
 #include "libavutil/opt.h"
+#include "libavutil/dict.h"
 #include "libavutil/time.h"
-#include "libavutil/parseutils.h"
+#include "avformat.h"
 #include "internal.h"
 #include "avio_internal.h"
-#include "dash.h"
+#include "url.h"
+#include "id3v2.h"
 
 #define INITIAL_BUFFER_SIZE 32768
 
-struct fragment {
+/////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////
+#include <time.h>
+#include <unistd.h>
+#include <string.h>
+
+static struct tm* ResolveUTCDateTime(const char *dateTimeString)
+{
+    time_t rawtime;
+    struct tm* timeInfo = NULL;
+    int y = 0;
+    int M = 0;
+    int d = 0;
+    int h = 0;
+    int m = 0;
+    float s = 0.0;
+
+    /* ISO-8601 date parser */
+
+    if (dateTimeString == NULL || '\0' == dateTimeString[0])
+        return NULL;
+
+
+    time ( &rawtime );
+    timeInfo = gmtime ( &rawtime );
+
+    sscanf(dateTimeString, "%d-%d-%dT%d:%d:%fZ", &y, &M, &d, &h, &m, &s);
+
+    timeInfo->tm_year = y - 1900;
+    timeInfo->tm_mon  = M - 1;
+    timeInfo->tm_mday = d;
+
+    timeInfo->tm_hour = h;
+    timeInfo->tm_min  = m;
+    timeInfo->tm_sec  = (int)s;
+
+    return timeInfo;
+}
+
+static struct tm*  GetCurrentUTCTime(void)
+{
+    time_t rawTime;
+    time(&rawTime);
+    return gmtime(&rawTime);
+}
+
+static uint32_t GetCurrentTimeInSec(void)
+{
+    return (uint32_t)mktime(GetCurrentUTCTime());
+}
+
+static uint32_t GetUTCDateTimeInSec(const char *datetime)
+{
+    return (uint32_t)mktime(ResolveUTCDateTime(datetime));
+}
+
+static uint32_t GetDurationInSec(const char *duration)
+{
+    /* ISO-8601 duration parser */
+
+    uint32_t days = 0;
+    uint32_t hours = 0;
+    uint32_t mins = 0;
+    uint32_t secs = 0;
+
+    const char *ptr = duration;
+    while(*ptr)
+    {
+        float value = 0;
+        uint32_t charsRead;
+        char type = '\0';
+
+        if(*ptr == 'P' || *ptr == 'T')
+        {
+            ptr++;
+            continue;
+        }
+
+        if(sscanf(ptr, "%f%c%n", &value, &type, &charsRead) != 2) {
+            return 0; /* parser error */
+        }
+        switch(type) {
+            case 'D':
+                days = (uint32_t)value;
+            break;
+            case 'H':
+                hours = (uint32_t)value;
+            break;
+            case 'M':
+                mins = (uint32_t)value;
+            break;
+            case 'S':
+                secs = (uint32_t)value;
+            break;
+            default:
+            // handle invalid type
+                break;
+        }
+        ptr += charsRead;
+    }
+    return  ((days * 24 + hours) * 60 + mins) * 60 + secs;
+}
+//###########################################################################
+
+struct segment {
+    //int64_t duration;
     int64_t url_offset;
     int64_t size;
     char *url;
 };
 
-/*
- * reference to : ISO_IEC_23009-1-DASH-2012
- * Section: 5.3.9.6.2
- * Table: Table 17 â€” Semantics of SegmentTimeline element
- * */
 struct timeline {
-    /* starttime: Element or Attribute Name
-     * specifies the MPD start time, in @timescale units,
-     * the first Segment in the series starts relative to the beginning of the Period.
-     * The value of this attribute must be equal to or greater than the sum of the previous S
-     * element earliest presentation time and the sum of the contiguous Segment durations.
-     * If the value of the attribute is greater than what is expressed by the previous S element,
-     * it expresses discontinuities in the timeline.
-     * If not present then the value shall be assumed to be zero for the first S element
-     * and for the subsequent S elements, the value shall be assumed to be the sum of
-     * the previous S element's earliest presentation time and contiguous duration
-     * (i.e. previous S@starttime + @duration * (@repeat + 1)).
-     * */
-    int64_t starttime;
-    /* repeat: Element or Attribute Name
-     * specifies the repeat count of the number of following contiguous Segments with
-     * the same duration expressed by the value of @duration. This value is zero-based
-     * (e.g. a value of three means four Segments in the contiguous series).
-     * */
-    int64_t repeat;
-    /* duration: Element or Attribute Name
-     * specifies the Segment duration, in units of the value of the @timescale.
-     * */
-    int64_t duration;
+    int64_t t;
+    int32_t r;
+    int64_t d;
+};
+
+enum RepType {
+    REP_TYPE_UNSPECIFIED,
+    REP_TYPE_AUDIO,
+    REP_TYPE_VIDEO
+};
+
+enum TemUrlType {
+    TMP_URL_TYPE_UNSPECIFIED,
+    TMP_URL_TYPE_NUMBER,
+    TMP_URL_TYPE_TIME
 };
 
 /*
- * Each playlist has its own demuxer. If it is currently active,
- * it has an opened AVIOContext too, and potentially an AVPacket
+ * Each playlist has its own demuxer. If it currently is active,
+ * it has an open AVIOContext too, and potentially an AVPacket
  * containing the next packet from this stream.
  */
 struct representation {
     char *url_template;
+    char *url_template_pattern;
+    char *url_template_format;
+    enum TemUrlType tmp_url_type;
     AVIOContext pb;
     AVIOContext *input;
     AVFormatContext *parent;
@@ -83,10 +190,11 @@ struct representation {
     int rep_count;
     int stream_index;
 
-    enum AVMediaType type;
+    enum RepType type;
+    int64_t target_duration;
 
-    int n_fragments;
-    struct fragment **fragments; /* VOD list of fragment for profile */
+    int n_segments;
+    struct segment **segments; /* VOD list of segment for profile */
 
     int n_timelines;
     struct timeline **timelines;
@@ -95,216 +203,85 @@ struct representation {
     int64_t last_seq_no;
     int64_t start_number; /* used in case when we have dynamic list of segment to know which segments are new one*/
 
-    int64_t fragment_duration;
-    int64_t fragment_timescale;
-
-    int64_t presentation_timeoffset;
+    int64_t segmentDuration;
+    int64_t segmentTimescalce;
 
     int64_t cur_seq_no;
     int64_t cur_seg_offset;
     int64_t cur_seg_size;
-    struct fragment *cur_seg;
+    struct segment *cur_seg;
 
     /* Currently active Media Initialization Section */
-    struct fragment *init_section;
+    struct segment *init_section;
     uint8_t *init_sec_buf;
     uint32_t init_sec_buf_size;
     uint32_t init_sec_data_len;
     uint32_t init_sec_buf_read_offset;
+    
+    int fix_multiple_stsd_order;
+
     int64_t cur_timestamp;
     int is_restart_needed;
 };
 
 typedef struct DASHContext {
-    const AVClass *class;
+    AVClass *class;
+
     char *base_url;
+
     struct representation *cur_video;
     struct representation *cur_audio;
 
-    /* MediaPresentationDescription Attribute */
-    uint64_t media_presentation_duration;
-    uint64_t suggested_presentation_delay;
-    uint64_t availability_start_time;
-    uint64_t publish_time;
-    uint64_t minimum_update_period;
-    uint64_t time_shift_buffer_depth;
-    uint64_t min_buffer_time;
+    uint32_t mediaPresentationDurationSec;
+
+    uint32_t suggestedPresentationDelaySec;
+    uint32_t presentationDelaySec;
+    uint32_t availabilityStartTimeSec;
+    uint32_t publishTimeSec;
+    uint32_t minimumUpdatePeriodSec;
+    uint32_t timeShiftBufferDepthSec;
+    uint32_t minBufferTimeSec;
 
-    /* Period Attribute */
-    uint64_t period_duration;
-    uint64_t period_start;
+    uint32_t periodDurationSec;
+    uint32_t periodStartSec;
 
     int is_live;
+
+    int audio_rep_index;
+    int video_rep_index;
+
     AVIOInterruptCB *interrupt_callback;
     char *user_agent;                    ///< holds HTTP user agent set as an AVOption to the HTTP protocol context
     char *cookies;                       ///< holds HTTP cookie values set in either the initial response or as an AVOption to the HTTP protocol context
     char *headers;                       ///< holds HTTP headers set as an AVOption to the HTTP protocol context
-    char *allowed_extensions;
     AVDictionary *avio_opts;
 } DASHContext;
 
-static uint64_t get_current_time_in_sec(void)
-{
-    return  av_gettime() / 1000000;
-}
-
-static uint64_t get_utc_date_time_insec(AVFormatContext *s, const char *datetime)
-{
-    struct tm timeinfo;
-    int year = 0;
-    int month = 0;
-    int day = 0;
-    int hour = 0;
-    int minute = 0;
-    int ret = 0;
-    float second = 0.0;
-
-    /* ISO-8601 date parser */
-    if (!datetime)
-        return 0;
-
-    ret = sscanf(datetime, "%d-%d-%dT%d:%d:%fZ", &year, &month, &day, &hour, &minute, &second);
-    /* year, month, day, hour, minute, second  6 arguments */
-    if (ret != 6) {
-        av_log(s, AV_LOG_WARNING, "get_utc_date_time_insec get a wrong time format\n");
-    }
-    timeinfo.tm_year = year - 1900;
-    timeinfo.tm_mon  = month - 1;
-    timeinfo.tm_mday = day;
-    timeinfo.tm_hour = hour;
-    timeinfo.tm_min  = minute;
-    timeinfo.tm_sec  = (int)second;
-
-    return av_timegm(&timeinfo);
-}
-
-static uint32_t get_duration_insec(AVFormatContext *s, const char *duration)
-{
-    /* ISO-8601 duration parser */
-    uint32_t days = 0;
-    uint32_t hours = 0;
-    uint32_t mins = 0;
-    uint32_t secs = 0;
-    int size = 0;
-    float value = 0;
-    char type = '\0';
-    const char *ptr = duration;
-
-    while (*ptr) {
-        if (*ptr == 'P' || *ptr == 'T') {
-            ptr++;
-            continue;
-        }
-
-        if (sscanf(ptr, "%f%c%n", &value, &type, &size) != 2) {
-            av_log(s, AV_LOG_WARNING, "get_duration_insec get a wrong time format\n");
-            return 0; /* parser error */
-        }
-        switch (type) {
-            case 'D':
-                days = (uint32_t)value;
-                break;
-            case 'H':
-                hours = (uint32_t)value;
-                break;
-            case 'M':
-                mins = (uint32_t)value;
-                break;
-            case 'S':
-                secs = (uint32_t)value;
-                break;
-            default:
-                // handle invalid type
-                break;
-        }
-        ptr += size;
-    }
-    return  ((days * 24 + hours) * 60 + mins) * 60 + secs;
-}
-
-static int64_t get_segment_start_time_based_on_timeline(struct representation *pls, int64_t cur_seq_no)
-{
-    int64_t start_time = 0;
-    int64_t i = 0;
-    int64_t j = 0;
-    int64_t num = 0;
-
-    if (pls->n_timelines) {
-        for (i = 0; i < pls->n_timelines; i++) {
-            if (pls->timelines[i]->starttime > 0) {
-                start_time = pls->timelines[i]->starttime;
-            }
-            if (num == cur_seq_no)
-                goto finish;
-
-            start_time += pls->timelines[i]->duration;
-            for (j = 0; j < pls->timelines[i]->repeat; j++) {
-                num++;
-                if (num == cur_seq_no)
-                    goto finish;
-                start_time += pls->timelines[i]->duration;
-            }
-            num++;
-        }
-    }
-finish:
-    return start_time;
-}
-
-static int64_t calc_next_seg_no_from_timelines(struct representation *pls, int64_t cur_time)
-{
-    int64_t i = 0;
-    int64_t j = 0;
-    int64_t num = 0;
-    int64_t start_time = 0;
-
-    for (i = 0; i < pls->n_timelines; i++) {
-        if (pls->timelines[i]->starttime > 0) {
-            start_time = pls->timelines[i]->starttime;
-        }
-        if (start_time > cur_time)
-            goto finish;
-
-        start_time += pls->timelines[i]->duration;
-        for (j = 0; j < pls->timelines[i]->repeat; j++) {
-            num++;
-            if (start_time > cur_time)
-                goto finish;
-            start_time += pls->timelines[i]->duration;
-        }
-        num++;
-    }
-
-    return -1;
 
-finish:
-    return num;
-}
-
-static void free_fragment(struct fragment **seg)
+static void free_segment(struct segment **seg)
 {
-    if (!(*seg)) {
+    if (!seg || !(*seg)) {
         return;
     }
+    
     av_freep(&(*seg)->url);
     av_freep(seg);
 }
 
-static void free_fragment_list(struct representation *pls)
+static void free_segment_list(struct representation *pls)
 {
     int i;
-
-    for (i = 0; i < pls->n_fragments; i++) {
-        free_fragment(&pls->fragments[i]);
+    for (i = 0; i < pls->n_segments; i++) {
+        av_freep(&pls->segments[i]->url);
+        av_freep(&pls->segments[i]);
     }
-    av_freep(&pls->fragments);
-    pls->n_fragments = 0;
+    av_freep(&pls->segments);
+    pls->n_segments = 0;
 }
 
 static void free_timelines_list(struct representation *pls)
 {
     int i;
-
     for (i = 0; i < pls->n_timelines; i++) {
         av_freep(&pls->timelines[i]);
     }
@@ -312,13 +289,25 @@ static void free_timelines_list(struct representation *pls)
     pls->n_timelines = 0;
 }
 
+/*
+ * Used to reset a statically allocated AVPacket to a clean slate,
+ * containing no data.
+ */
+static void reset_packet(AVPacket *pkt)
+{
+    av_init_packet(pkt);
+    pkt->data = NULL;
+}
+
 static void free_representation(struct representation *pls)
 {
-    free_fragment_list(pls);
+    free_segment_list(pls);
     free_timelines_list(pls);
-    free_fragment(&pls->cur_seg);
-    free_fragment(&pls->init_section);
+    free_segment(&pls->cur_seg);
+    free_segment(&pls->init_section);
     av_freep(&pls->init_sec_buf);
+    av_packet_unref(&pls->pkt);
+    reset_packet(&pls->pkt);
     av_freep(&pls->pb.buffer);
     if (pls->input)
         ff_format_io_close(pls->parent, &pls->input);
@@ -327,25 +316,17 @@ static void free_representation(struct representation *pls)
         avformat_close_input(&pls->ctx);
     }
 
-    av_freep(&pls->url_template);
-    av_freep(&pls);
+    av_free(pls->url_template_pattern);
+    av_free(pls->url_template_format);
+    av_free(pls->url_template);
+    av_free(pls);
 }
 
-static void set_httpheader_options(DASHContext *c, AVDictionary **opts)
-{
-    // broker prior HTTP options that should be consistent across requests
-    av_dict_set(opts, "user-agent", c->user_agent, 0);
-    av_dict_set(opts, "cookies", c->cookies, 0);
-    av_dict_set(opts, "headers", c->headers, 0);
-    if (c->is_live) {
-        av_dict_set(opts, "seekable", "0", 0);
-    }
-}
 static void update_options(char **dest, const char *name, void *src)
 {
     av_freep(dest);
     av_opt_get(src, name, AV_OPT_SEARCH_CHILDREN, (uint8_t**)dest);
-    if (*dest)
+    if (*dest && !strlen(*dest))
         av_freep(dest);
 }
 
@@ -360,11 +341,6 @@ static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,
     av_dict_copy(&tmp, opts, 0);
     av_dict_copy(&tmp, opts2, 0);
 
-    if (av_strstart(url, "crypto", NULL)) {
-        if (url[6] == '+' || url[6] == ':')
-            proto_name = avio_find_protocol_name(url + 7);
-    }
-
     if (!proto_name)
         proto_name = avio_find_protocol_name(url);
 
@@ -372,39 +348,18 @@ static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,
         return AVERROR_INVALIDDATA;
 
     // only http(s) & file are allowed
-    if (av_strstart(proto_name, "file", NULL)) {
-        if (strcmp(c->allowed_extensions, "ALL") && !av_match_ext(url, c->allowed_extensions)) {
-            av_log(s, AV_LOG_ERROR,
-                "Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n"
-                "If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n",
-                url);
-            return AVERROR_INVALIDDATA;
-        }
-    } else if (av_strstart(proto_name, "http", NULL)) {
-        ;
-    } else
+    if (!av_strstart(proto_name, "http", NULL) && !av_strstart(proto_name, "file", NULL))
         return AVERROR_INVALIDDATA;
-
     if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')
         ;
-    else if (av_strstart(url, "crypto", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')
-        ;
     else if (strcmp(proto_name, "file") || !strncmp(url, "file,", 5))
         return AVERROR_INVALIDDATA;
 
     ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);
     if (ret >= 0) {
         // update cookies on http response with setcookies.
-        char *new_cookies = NULL;
-
-        if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))
-            av_opt_get(*pb, "cookies", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);
-
-        if (new_cookies) {
-            av_free(c->cookies);
-            c->cookies = new_cookies;
-        }
-
+        void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;
+        update_options(&c->cookies, "cookies", u);
         av_dict_set(&opts, "cookies", c->cookies, 0);
     }
 
@@ -416,477 +371,321 @@ static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,
     return ret;
 }
 
-static char *get_content_url(xmlNodePtr *baseurl_nodes,
-                             int n_baseurl_nodes,
-                             char *rep_id_val,
-                             char *rep_bandwidth_val,
-                             char *val)
-{
-    int i;
-    char *text;
-    char *url = NULL;
-    char tmp_str[MAX_URL_SIZE];
-    char tmp_str_2[MAX_URL_SIZE];
+/////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////
+#include <libxml/parser.h>
+#include <libxml/tree.h>
 
-    memset(tmp_str, 0, sizeof(tmp_str));
+#include <string.h>
+#include <stdlib.h>
+#include <stddef.h>
 
-    for (i = 0; i < n_baseurl_nodes; ++i) {
-        if (baseurl_nodes[i] &&
-            baseurl_nodes[i]->children &&
-            baseurl_nodes[i]->children->type == XML_TEXT_NODE) {
-            text = xmlNodeGetContent(baseurl_nodes[i]->children);
-            if (text) {
-                memset(tmp_str, 0, sizeof(tmp_str));
-                memset(tmp_str_2, 0, sizeof(tmp_str_2));
-                ff_make_absolute_url(tmp_str_2, MAX_URL_SIZE, tmp_str, text);
-                av_strlcpy(tmp_str, tmp_str_2, sizeof(tmp_str));
-                xmlFree(text);
+#if (__STDC_VERSION__ >= 199901L)
+#include <stdint.h>
+#endif
+
+//http://creativeandcritical.net/str-replace-c
+
+static char *repl_str(const char *str, const char *from, const char *to)
+{
+    /* Adjust each of the below values to suit your needs. */
+
+    /* Increment positions cache size initially by this number. */
+    size_t cache_sz_inc = 16;
+    /* Thereafter, each time capacity needs to be increased,
+     * multiply the increment by this factor. */
+    const size_t cache_sz_inc_factor = 3;
+    /* But never increment capacity by more than this number. */
+    const size_t cache_sz_inc_max = 1048576;
+
+    char *pret, *ret = NULL;
+    const char *pstr2, *pstr = str;
+    size_t i, count = 0;
+    #if (__STDC_VERSION__ >= 199901L)
+    uintptr_t *pos_cache_tmp, *pos_cache = NULL;
+    #else
+    ptrdiff_t *pos_cache_tmp, *pos_cache = NULL;
+    #endif
+    size_t cache_sz = 0;
+    size_t cpylen, orglen, retlen, tolen, fromlen = strlen(from);
+
+    /* Find all matches and cache their positions. */
+    while ((pstr2 = strstr(pstr, from)) != NULL) {
+        count++;
+
+        /* Increase the cache size when necessary. */
+        if (cache_sz < count) {
+            cache_sz += cache_sz_inc;
+            pos_cache_tmp = realloc(pos_cache, sizeof(*pos_cache) * cache_sz);
+            if (pos_cache_tmp == NULL) {
+                goto end_repl_str;
+            } else pos_cache = pos_cache_tmp;
+            cache_sz_inc *= cache_sz_inc_factor;
+            if (cache_sz_inc > cache_sz_inc_max) {
+                cache_sz_inc = cache_sz_inc_max;
             }
         }
+
+        pos_cache[count-1] = pstr2 - str;
+        pstr = pstr2 + fromlen;
     }
 
-    if (val)
-        av_strlcat(tmp_str, (const char*)val, sizeof(tmp_str));
+    orglen = pstr - str + strlen(pstr);
 
-    if (rep_id_val) {
-        url = av_strireplace(tmp_str, "$RepresentationID$", (const char*)rep_id_val);
-        if (!url) {
-            return NULL;
-        }
-        av_strlcpy(tmp_str, url, sizeof(tmp_str));
-        av_free(url);
+    /* Allocate memory for the post-replacement string. */
+    if (count > 0) {
+        tolen = strlen(to);
+        retlen = orglen + (tolen - fromlen) * count;
+    } else	retlen = orglen;
+    ret = av_malloc(retlen + 1);
+    if (ret == NULL) {
+        goto end_repl_str;
     }
-    if (rep_bandwidth_val && tmp_str[0] != '\0') {
-        url = av_strireplace(tmp_str, "$Bandwidth$", (const char*)rep_bandwidth_val);
-        if (!url) {
-            return NULL;
+
+    if (count == 0) {
+        /* If no matches, then just duplicate the string. */
+        strcpy(ret, str);
+    } else {
+        /* Otherwise, duplicate the string whilst performing
+         * the replacements using the position cache. */
+        pret = ret;
+        memcpy(pret, str, pos_cache[0]);
+        pret += pos_cache[0];
+        for (i = 0; i < count; i++) {
+            memcpy(pret, to, tolen);
+            pret += tolen;
+            pstr = str + pos_cache[i] + fromlen;
+            cpylen = (i == count-1 ? orglen : pos_cache[i+1]) - pos_cache[i] - fromlen;
+            memcpy(pret, pstr, cpylen);
+            pret += cpylen;
         }
+        ret[retlen] = '\0';
     }
-    return url;
+
+end_repl_str:
+    /* Free the cache and return the post-replacement string,
+     * which will be NULL in the event of an error. */
+    free(pos_cache);
+    return ret;
 }
 
-static char *get_val_from_nodes_tab(xmlNodePtr *nodes, const int n_nodes, const char *attrname)
+static int get_repl_pattern_and_format(const char *i_url, const char *i_marker, char **o_pattern, char **o_format)
 {
-    int i;
-    char *val;
+    int ret = -1;
 
-    for (i = 0; i < n_nodes; ++i) {
-        if (nodes[i]) {
-            val = xmlGetProp(nodes[i], attrname);
-            if (val)
-                return val;
-        }
-    }
+    if (NULL != strstr(i_url, i_marker)) {
+        *o_pattern = av_strdup(i_marker);
+        *o_format = av_strdup("%"PRId64);
+        ret = 0;
+    } else {
+        char *prefix = NULL;
+        char *start  = NULL;
+        char *end    = NULL;
+        int marker_len = 0;
+        int format_len = 0;
+
+        prefix = av_strdup(i_marker);
+        marker_len = strlen(prefix)-1;
+        prefix[marker_len] = '\0';
+
+        start = strstr(i_url, prefix);
+        if (!start)
+            goto finish;
+        end = strchr(start+1, '$');
+        if (!end)
+            goto finish;
 
-    return NULL;
-}
+        if (start[marker_len] != '%')
+            goto finish;
 
-static xmlNodePtr find_child_node_by_name(xmlNodePtr rootnode, const char *nodename)
-{
-    xmlNodePtr node = rootnode;
-    if (!node) {
-        return NULL;
-    }
+        if (end[-1] != 'd')
+            goto finish;
 
-    node = xmlFirstElementChild(node);
-    while (node) {
-        if (!av_strcasecmp(node->name, nodename)) {
-            return node;
-        }
-        node = xmlNextElementSibling(node);
+        format_len = end - start - marker_len - 1 + strlen(PRId64);
+        *o_format = av_mallocz(format_len+1);
+        strncpy(*o_format, start + marker_len, end - start - marker_len -1);
+        strcat(*o_format, PRId64);
+        
+        *o_pattern = av_mallocz(end - start + 2);
+        strncpy(*o_pattern, start, end - start + 1);
+
+        ret = 0;
+finish:
+        free(prefix);
     }
-    return NULL;
+
+    return ret;
 }
 
-static enum AVMediaType get_content_type(xmlNodePtr node)
+static char * get_content_url(xmlNodePtr *baseUrlNodes, int n_baseUrlNodes, xmlChar *rep_id_val, xmlChar *rep_bandwidth_val, xmlChar *val)
 {
-    enum AVMediaType type = AVMEDIA_TYPE_UNKNOWN;
+    char *tmp_str = av_mallocz(MAX_URL_SIZE);
+    char *url = NULL;
     int i = 0;
-    const char *attr;
-    char *val = NULL;
-
-    if (node) {
-        for (i = 0; i < 2; i++) {
-            attr = i ? "mimeType" : "contentType";
-            val = xmlGetProp(node, attr);
-            if (val) {
-                if (av_stristr((const char *)val, "video")) {
-                    type = AVMEDIA_TYPE_VIDEO;
-                } else if (av_stristr((const char *)val, "audio")) {
-                    type = AVMEDIA_TYPE_AUDIO;
-                }
-                xmlFree(val);
-            }
-        }
-    }
-    return type;
-}
 
-static int parse_manifest_segmenturlnode(AVFormatContext *s, struct representation *rep,
-                                         xmlNodePtr fragmenturl_node,
-                                         xmlNodePtr *baseurl_nodes,
-                                         char *rep_id_val,
-                                         char *rep_bandwidth_val)
-{
-    char *initialization_val = NULL;
-    char *media_val = NULL;
-
-    if (!av_strcasecmp(fragmenturl_node->name, (const char *)"Initialization")) {
-        initialization_val = xmlGetProp(fragmenturl_node, "sourceURL");
-        if (initialization_val) {
-            rep->init_section = av_mallocz(sizeof(struct fragment));
-            if (!rep->init_section) {
-                xmlFree(initialization_val);
-                return AVERROR(ENOMEM);
-            }
-            rep->init_section->url = get_content_url(baseurl_nodes, 4,
-                                                     rep_id_val,
-                                                     rep_bandwidth_val,
-                                                     initialization_val);
-            if (!rep->init_section->url) {
-                av_free(rep->init_section);
-                xmlFree(initialization_val);
-                return AVERROR(ENOMEM);
-            }
-            rep->init_section->size = -1;
-            xmlFree(initialization_val);
-        }
-    } else if (!av_strcasecmp(fragmenturl_node->name, (const char *)"SegmentURL")) {
-        media_val = xmlGetProp(fragmenturl_node, "media");
-        if (media_val) {
-            struct fragment *seg = av_mallocz(sizeof(struct fragment));
-            if (!seg) {
-                xmlFree(media_val);
-                return AVERROR(ENOMEM);
-            }
-            seg->url = get_content_url(baseurl_nodes, 4,
-                                       rep_id_val,
-                                       rep_bandwidth_val,
-                                       media_val);
-            if (!seg->url) {
-                av_free(seg);
-                xmlFree(media_val);
-                return AVERROR(ENOMEM);
+    for (; i < n_baseUrlNodes; ++i) {
+        if (baseUrlNodes[i] && baseUrlNodes[i]->children && baseUrlNodes[i]->children->type == XML_TEXT_NODE) {
+            xmlChar *text = xmlNodeGetContent(baseUrlNodes[i]->children);
+            if (text) {
+                char *tmp_str_2 = av_mallocz(MAX_URL_SIZE);
+                ff_make_absolute_url(tmp_str_2, MAX_URL_SIZE, tmp_str, text);
+                av_free(tmp_str);
+                tmp_str = tmp_str_2;
+                xmlFree(text);
             }
-            seg->size = -1;
-            dynarray_add(&rep->fragments, &rep->n_fragments, seg);
-            xmlFree(media_val);
         }
     }
 
-    return 0;
-}
-
-static int parse_manifest_segmenttimeline(AVFormatContext *s, struct representation *rep,
-                                          xmlNodePtr fragment_timeline_node)
-{
-    xmlAttrPtr attr = NULL;
-    char *val  = NULL;
-
-    if (!av_strcasecmp(fragment_timeline_node->name, (const char *)"S")) {
-        struct timeline *tml = av_mallocz(sizeof(struct timeline));
-        if (!tml) {
-            return AVERROR(ENOMEM);
-        }
-        attr = fragment_timeline_node->properties;
-        while (attr) {
-            val = xmlGetProp(fragment_timeline_node, attr->name);
+    url = tmp_str;
 
-            if (!val) {
-                av_log(s, AV_LOG_WARNING, "parse_manifest_segmenttimeline attr->name = %s val is NULL\n", attr->name);
-                continue;
-            }
+    if (val)
+        strcat(tmp_str, (const char*)val);
 
-            if (!av_strcasecmp(attr->name, (const char *)"t")) {
-                tml->starttime = (int64_t)strtoll(val, NULL, 10);
-            } else if (!av_strcasecmp(attr->name, (const char *)"r")) {
-                tml->repeat =(int64_t) strtoll(val, NULL, 10);
-            } else if (!av_strcasecmp(attr->name, (const char *)"d")) {
-                tml->duration = (int64_t)strtoll(val, NULL, 10);
+    if (rep_id_val) {
+        url = repl_str(tmp_str, "$RepresentationID$", (const char*)rep_id_val);
+        av_free(tmp_str);
+        tmp_str = url;
+    }
+
+    if (rep_bandwidth_val && tmp_str){
+        char *pFormat = NULL;
+        char *pPattern = NULL;
+        
+        if (0 == get_repl_pattern_and_format(tmp_str, "$Bandwidth$", &pPattern, &pFormat)) {
+            int64_t val = (int64_t)atoll((const char *)rep_bandwidth_val);
+            int size = snprintf(NULL, 0, pFormat, val); // calc needed buffer size
+            if (val > 0) {
+                char *tmp_val = av_mallocz(size + 1);
+                snprintf(tmp_val, size+1, pFormat, val);
+                
+                url = repl_str(tmp_str, pPattern, tmp_val);
+                av_free(tmp_val);
+                
+                av_free(tmp_str);
+                tmp_str = NULL;
             }
-            attr = attr->next;
-            xmlFree(val);
+            av_free(pFormat);
+            av_free(pPattern);
         }
-        dynarray_add(&rep->timelines, &rep->n_timelines, tml);
     }
 
-    return 0;
+    if (tmp_str != url)
+        av_free(tmp_str);
+
+    return url;
 }
 
-static int parse_manifest_representation(AVFormatContext *s, const char *url,
-                                         xmlNodePtr node,
-                                         xmlNodePtr adaptionset_node,
-                                         xmlNodePtr mpd_baseurl_node,
-                                         xmlNodePtr period_baseurl_node,
-                                         xmlNodePtr fragment_template_node,
-                                         xmlNodePtr content_component_node,
-                                         xmlNodePtr adaptionset_baseurl_node)
+static xmlChar * get_val_from_nodes_tab(xmlNodePtr *nodes, const int n_nodes, const xmlChar *attrName)
 {
-    int32_t ret = 0;
-    int32_t audio_rep_idx = 0;
-    int32_t video_rep_idx = 0;
-    DASHContext *c = s->priv_data;
-    struct representation *rep = NULL;
-    struct fragment *seg = NULL;
-    xmlNodePtr representation_segmenttemplate_node = NULL;
-    xmlNodePtr representation_baseurl_node = NULL;
-    xmlNodePtr representation_segmentlist_node = NULL;
-    xmlNodePtr fragment_timeline_node = NULL;
-    xmlNodePtr fragment_templates_tab[2];
-    char *duration_val = NULL;
-    char *presentation_timeoffset_val = NULL;
-    char *startnumber_val = NULL;
-    char *timescale_val = NULL;
-    char *initialization_val = NULL;
-    char *media_val = NULL;
-    xmlNodePtr baseurl_nodes[4];
-    xmlNodePtr representation_node = node;
-    char *rep_id_val = xmlGetProp(representation_node, "id");
-    char *rep_bandwidth_val = xmlGetProp(representation_node, "bandwidth");
-    enum AVMediaType type = AVMEDIA_TYPE_UNKNOWN;
-
-    // try get information from representation
-    if (type == AVMEDIA_TYPE_UNKNOWN)
-        type = get_content_type(representation_node);
-    // try get information from contentComponen
-    if (type == AVMEDIA_TYPE_UNKNOWN)
-        type = get_content_type(content_component_node);
-    // try get information from adaption set
-    if (type == AVMEDIA_TYPE_UNKNOWN)
-        type = get_content_type(adaptionset_node);
-    if (type == AVMEDIA_TYPE_UNKNOWN) {
-        av_log(s, AV_LOG_VERBOSE, "Parsing '%s' - skipp not supported representation type\n", url);
-    } else if ((type == AVMEDIA_TYPE_VIDEO && !c->cur_video) || (type == AVMEDIA_TYPE_AUDIO && !c->cur_audio)) {
-        // convert selected representation to our internal struct
-        rep = av_mallocz(sizeof(struct representation));
-        if (!rep) {
-            ret = AVERROR(ENOMEM);
-            goto end;
-        }
-        representation_segmenttemplate_node = find_child_node_by_name(representation_node, "SegmentTemplate");
-        representation_baseurl_node = find_child_node_by_name(representation_node, "BaseURL");
-        representation_segmentlist_node = find_child_node_by_name(representation_node, "SegmentList");
-
-        baseurl_nodes[0] = mpd_baseurl_node;
-        baseurl_nodes[1] = period_baseurl_node;
-        baseurl_nodes[2] = adaptionset_baseurl_node;
-        baseurl_nodes[3] = representation_baseurl_node;
-
-        if (representation_segmenttemplate_node || fragment_template_node) {
-            fragment_timeline_node = NULL;
-            fragment_templates_tab[0] = representation_segmenttemplate_node;
-            fragment_templates_tab[1] = fragment_template_node;
-
-            presentation_timeoffset_val = get_val_from_nodes_tab(fragment_templates_tab, 2, "presentationTimeOffset");
-            duration_val = get_val_from_nodes_tab(fragment_templates_tab, 2, "duration");
-            startnumber_val = get_val_from_nodes_tab(fragment_templates_tab, 2, "startNumber");
-            timescale_val = get_val_from_nodes_tab(fragment_templates_tab, 2, "timescale");
-            initialization_val = get_val_from_nodes_tab(fragment_templates_tab, 2, "initialization");
-            media_val = get_val_from_nodes_tab(fragment_templates_tab, 2, "media");
-
-            if (initialization_val) {
-                rep->init_section = av_mallocz(sizeof(struct fragment));
-                if (!rep->init_section) {
-                    av_free(rep);
-                    ret = AVERROR(ENOMEM);
-                    goto end;
-                }
-                rep->init_section->url = get_content_url(baseurl_nodes, 4, rep_id_val, rep_bandwidth_val, initialization_val);
-                if (!rep->init_section->url) {
-                    av_free(rep->init_section);
-                    av_free(rep);
-                    ret = AVERROR(ENOMEM);
-                    goto end;
-                }
-                rep->init_section->size = -1;
-                xmlFree(initialization_val);
-            }
-
-            if (media_val) {
-                rep->url_template = get_content_url(baseurl_nodes, 4, rep_id_val, rep_bandwidth_val, media_val);
-                xmlFree(media_val);
-            }
-
-            if (presentation_timeoffset_val) {
-                rep->presentation_timeoffset = (int64_t) strtoll(presentation_timeoffset_val, NULL, 10);
-                xmlFree(presentation_timeoffset_val);
-            }
-            if (duration_val) {
-                rep->fragment_duration = (int64_t) strtoll(duration_val, NULL, 10);
-                xmlFree(duration_val);
-            }
-            if (timescale_val) {
-                rep->fragment_timescale = (int64_t) strtoll(timescale_val, NULL, 10);
-                xmlFree(timescale_val);
-            }
-            if (startnumber_val) {
-                rep->first_seq_no = (int64_t) strtoll(startnumber_val, NULL, 10);
-                xmlFree(startnumber_val);
-            }
-
-            fragment_timeline_node = find_child_node_by_name(representation_segmenttemplate_node, "SegmentTimeline");
-
-            if (!fragment_timeline_node)
-                fragment_timeline_node = find_child_node_by_name(fragment_template_node, "SegmentTimeline");
-            if (fragment_timeline_node) {
-                fragment_timeline_node = xmlFirstElementChild(fragment_timeline_node);
-                while (fragment_timeline_node) {
-                    ret = parse_manifest_segmenttimeline(s, rep, fragment_timeline_node);
-                    if (ret < 0) {
-                        return ret;
-                    }
-                    fragment_timeline_node = xmlNextElementSibling(fragment_timeline_node);
-                }
-            }
-        } else if (representation_baseurl_node && !representation_segmentlist_node) {
-            seg = av_mallocz(sizeof(struct fragment));
-            if (!seg) {
-                ret = AVERROR(ENOMEM);
-                goto end;
-            }
-            seg->url = get_content_url(baseurl_nodes, 4, rep_id_val, rep_bandwidth_val, NULL);
-            if (!seg->url) {
-                av_free(seg);
-                ret = AVERROR(ENOMEM);
-                goto end;
-            }
-            seg->size = -1;
-            dynarray_add(&rep->fragments, &rep->n_fragments, seg);
-        } else if (representation_segmentlist_node) {
-            // TODO: https://www.brendanlong.com/the-structure-of-an-mpeg-dash-mpd.html
-            // http://www-itec.uni-klu.ac.at/dash/ddash/mpdGenerator.php?fragmentlength=15&type=full
-            xmlNodePtr fragmenturl_node = NULL;
-            duration_val = xmlGetProp(representation_segmentlist_node, "duration");
-            timescale_val = xmlGetProp(representation_segmentlist_node, "timescale");
-            if (duration_val) {
-                rep->fragment_duration = (int64_t) strtoll(duration_val, NULL, 10);
-                xmlFree(duration_val);
-            }
-            if (timescale_val) {
-                rep->fragment_timescale = (int64_t) strtoll(timescale_val, NULL, 10);
-                xmlFree(timescale_val);
-            }
-            fragmenturl_node = xmlFirstElementChild(representation_segmentlist_node);
-            while (fragmenturl_node) {
-                ret = parse_manifest_segmenturlnode(s, rep, fragmenturl_node,
-                                                    baseurl_nodes,
-                                                    rep_id_val,
-                                                    rep_bandwidth_val);
-                if (ret < 0) {
-                    return ret;
-                }
-                fragmenturl_node = xmlNextElementSibling(fragmenturl_node);
-            }
+    int i;
+    for (i = 0; i < n_nodes; ++i) {
+        if (nodes[i]) {
+            xmlChar *val = xmlGetProp(nodes[i], attrName);
+            if (val)
+                return val;
+        }
+    }
+    return NULL;
+}
+
+static xmlNodePtr findChildNodeByName(xmlNodePtr rootnode, const xmlChar *nodename)
+{
+    xmlNodePtr node = rootnode;
+    if (node == NULL) {
+        return NULL;
+    }
 
-            fragment_timeline_node = find_child_node_by_name(representation_segmenttemplate_node, "SegmentTimeline");
+    node = xmlFirstElementChild(node);
+    while (node != NULL) {
 
-            if (!fragment_timeline_node)
-                fragment_timeline_node = find_child_node_by_name(fragment_template_node, "SegmentTimeline");
-            if (fragment_timeline_node) {
-                fragment_timeline_node = xmlFirstElementChild(fragment_timeline_node);
-                while (fragment_timeline_node) {
-                    ret = parse_manifest_segmenttimeline(s, rep, fragment_timeline_node);
-                    if (ret < 0) {
-                        return ret;
-                    }
-                    fragment_timeline_node = xmlNextElementSibling(fragment_timeline_node);
-                }
-            }
-        } else {
-            free_representation(rep);
-            rep = NULL;
-            av_log(s, AV_LOG_ERROR, "Unknown format of Representation node id[%s] \n", (const char *)rep_id_val);
+        if (!xmlStrcmp(node->name, nodename)) {
+            return node; 
         }
+        node = xmlNextElementSibling(node);
+    }
+    return NULL;
+}
 
-        if (rep) {
-            if (rep->fragment_duration > 0 && !rep->fragment_timescale)
-                rep->fragment_timescale = 1;
-            if (type == AVMEDIA_TYPE_VIDEO) {
-                rep->rep_idx = video_rep_idx;
-                c->cur_video = rep;
-            } else {
-                rep->rep_idx = audio_rep_idx;
-                c->cur_audio = rep;
+static enum RepType get_content_type(xmlNodePtr node) 
+{
+    enum RepType type = REP_TYPE_UNSPECIFIED;
+    if (node) {
+        int i = 0;
+        while (type == REP_TYPE_UNSPECIFIED && i < 2) {
+            const char *attr = (i == 0) ? "contentType" : "mimeType"; 
+            xmlChar *val = xmlGetProp(node, attr);
+            if (val) {
+                if (strstr((const char *) val, "video"))
+                    type = REP_TYPE_VIDEO;
+                else if (strstr((const char *) val, "audio"))
+                    type = REP_TYPE_AUDIO;
+                xmlFree(val);
             }
+            i += 1;
         }
     }
-
-    video_rep_idx += type == AVMEDIA_TYPE_VIDEO;
-    audio_rep_idx += type == AVMEDIA_TYPE_AUDIO;
-
-end:
-    if (rep_id_val)
-        xmlFree(rep_id_val);
-    if (rep_bandwidth_val)
-        xmlFree(rep_bandwidth_val);
-
-    return ret;
+    return type;
 }
 
-static int parse_manifest_adaptationset(AVFormatContext *s, const char *url,
-                                        xmlNodePtr adaptionset_node,
-                                        xmlNodePtr mpd_baseurl_node,
-                                        xmlNodePtr period_baseurl_node)
+static void fill_timelines(struct representation *rep, xmlNodePtr *nodes, const int n_nodes)
 {
-    int ret = 0;
-    xmlNodePtr fragment_template_node = NULL;
-    xmlNodePtr content_component_node = NULL;
-    xmlNodePtr adaptionset_baseurl_node = NULL;
-    xmlNodePtr node = NULL;
-
-    node = xmlFirstElementChild(adaptionset_node);
-    while (node) {
-        if (!av_strcasecmp(node->name, (const char *)"SegmentTemplate")) {
-            fragment_template_node = node;
-        } else if (!av_strcasecmp(node->name, (const char *)"ContentComponent")) {
-            content_component_node = node;
-        } else if (!av_strcasecmp(node->name, (const char *)"BaseURL")) {
-            adaptionset_baseurl_node = node;
-        } else if (!av_strcasecmp(node->name, (const char *)"Representation")) {
-            ret = parse_manifest_representation(s, url, node,
-                                                adaptionset_node,
-                                                mpd_baseurl_node,
-                                                period_baseurl_node,
-                                                fragment_template_node,
-                                                content_component_node,
-                                                adaptionset_baseurl_node);
-            if (ret < 0) {
-                return ret;
+    int i = 0;
+    for (; i < n_nodes; ++i) {
+        if (nodes[i]) {
+            xmlNodePtr segmentTimelineNode = findChildNodeByName(nodes[i], "SegmentTimeline");
+            if (segmentTimelineNode) {
+                segmentTimelineNode = xmlFirstElementChild(segmentTimelineNode);
+                while (segmentTimelineNode) {
+                    if (!xmlStrcmp(segmentTimelineNode->name, (const xmlChar *)"S")) {
+                        struct timeline *tml = av_mallocz(sizeof(struct timeline));
+                        xmlAttrPtr attr = segmentTimelineNode->properties;
+                        while(attr) {
+                            xmlChar *val = xmlGetProp(segmentTimelineNode, attr->name);
+
+                            if (!xmlStrcmp(attr->name, (const xmlChar *)"t"))
+                                tml->t = (int64_t)atoll((const char *)val);
+                            else if (!xmlStrcmp(attr->name, (const xmlChar *)"r"))
+                                tml->r =(int32_t) atoi((const char *)val);
+                            else if (!xmlStrcmp(attr->name, (const xmlChar *)"d"))
+                                tml->d = (int64_t)atoll((const char *)val);
+                            attr = attr->next;
+                            xmlFree(val);
+                        }
+                        
+                        dynarray_add(&rep->timelines, &rep->n_timelines, tml);
+                    }
+                    segmentTimelineNode = xmlNextElementSibling(segmentTimelineNode);
+                }
+                return;
             }
         }
-        node = xmlNextElementSibling(node);
     }
-    return 0;
+    return;
 }
 
-static int parse_manifest(AVFormatContext *s, const char *url, AVIOContext *in)
+static int parse_mainifest(AVFormatContext *s, const char *url, AVIOContext *in)
 {
     DASHContext *c = s->priv_data;
     int ret = 0;
     int close_in = 0;
     uint8_t *new_url = NULL;
+
     int64_t filesize = 0;
     char *buffer = NULL;
-    AVDictionary *opts = NULL;
-    xmlDoc *doc = NULL;
-    xmlNodePtr root_element = NULL;
-    xmlNodePtr node = NULL;
-    xmlNodePtr period_node = NULL;
-    xmlNodePtr mpd_baseurl_node = NULL;
-    xmlNodePtr period_baseurl_node = NULL;
-    xmlNodePtr adaptionset_node = NULL;
-    xmlAttrPtr attr = NULL;
-    char *val  = NULL;
-    uint32_t perdiod_duration_sec = 0;
-    uint32_t perdiod_start_sec = 0;
-    int32_t audio_rep_idx = 0;
-    int32_t video_rep_idx = 0;
 
     if (!in) {
+        AVDictionary *opts = NULL;
         close_in = 1;
+        /* This is XML mainfest there is no need to set range header */
+        av_dict_set(&opts, "seekable", "0", 0);
+
+        // broker prior HTTP options that should be consistent across requests
+        av_dict_set(&opts, "user-agent", c->user_agent, 0);
+        av_dict_set(&opts, "cookies", c->cookies, 0);
+        av_dict_set(&opts, "headers", c->headers, 0);
 
-        set_httpheader_options(c, &opts);
-        ret = avio_open2(&in, url, AVIO_FLAG_READ, c->interrupt_callback, &opts);
+        ret = avio_open2(&in, url, AVIO_FLAG_READ,
+                         c->interrupt_callback, &opts);
         av_dict_free(&opts);
         if (ret < 0)
             return ret;
@@ -899,21 +698,34 @@ static int parse_manifest(AVFormatContext *s, const char *url, AVIOContext *in)
     }
 
     filesize = avio_size(in);
-    if (filesize <= 0) {
+    if (filesize <= 0){
         filesize = 8 * 1024;
     }
 
     buffer = av_mallocz(filesize);
+
     if (!buffer) {
-        av_free(c->base_url);
         return AVERROR(ENOMEM);
     }
 
     filesize = avio_read(in, buffer, filesize);
-    if (filesize <= 0) {
-        av_log(s, AV_LOG_ERROR, "Unable to read to offset '%s'\n", url);
-        ret = AVERROR_INVALIDDATA;
-    } else {
+    if (filesize > 0) {
+        xmlDoc *doc = NULL;
+        xmlNodePtr root_element = NULL;
+        xmlNodePtr node = NULL;
+        xmlNodePtr periodNode = NULL;
+        xmlNodePtr periodSegmentListNode = NULL;
+        xmlNodePtr mpdBaseUrlNode = NULL;
+        xmlNodePtr periodBaseUrlNode = NULL;
+        xmlNodePtr adaptionSetNode = NULL;
+        xmlAttrPtr attr = NULL;
+        xmlChar *val  = NULL;
+        uint32_t perdiodDurationSec = 0;
+        uint32_t perdiodStartSec = 0;
+
+        int32_t audioRepIdx = 0;
+        int32_t videoRepIdx = 0;
+
         LIBXML_TEST_VERSION
 
         doc = xmlReadMemory(buffer, filesize, c->base_url, NULL, 0);
@@ -926,8 +738,8 @@ static int parse_manifest(AVFormatContext *s, const char *url, AVIOContext *in)
             goto cleanup;
         }
 
-        if (node->type != XML_ELEMENT_NODE ||
-            av_strcasecmp(node->name, (const char *)"MPD")) {
+        if (node->type != XML_ELEMENT_NODE || 
+            xmlStrcmp(node->name, (const xmlChar *)"MPD")) {
             ret = AVERROR_INVALIDDATA;
             av_log(s, AV_LOG_ERROR, "Unable to parse '%s' - wrong root node name[%s] type[%d]\n", url, node->name, (int)node->type);
             goto cleanup;
@@ -939,89 +751,293 @@ static int parse_manifest(AVFormatContext *s, const char *url, AVIOContext *in)
             ret = AVERROR_INVALIDDATA;
             goto cleanup;
         }
-        if (!av_strcasecmp(val, (const char *)"dynamic"))
+        if (!xmlStrcmp(val, (const xmlChar *)"dynamic"))
             c->is_live = 1;
         xmlFree(val);
 
         attr = node->properties;
-        while (attr) {
+        while(attr) {
             val = xmlGetProp(node, attr->name);
 
-            if (!av_strcasecmp(attr->name, (const char *)"availabilityStartTime")) {
-                c->availability_start_time = get_utc_date_time_insec(s, (const char *)val);
-            } else if (!av_strcasecmp(attr->name, (const char *)"publishTime")) {
-                c->publish_time = get_utc_date_time_insec(s, (const char *)val);
-            } else if (!av_strcasecmp(attr->name, (const char *)"minimumUpdatePeriod")) {
-                c->minimum_update_period = get_duration_insec(s, (const char *)val);
-            } else if (!av_strcasecmp(attr->name, (const char *)"timeShiftBufferDepth")) {
-                c->time_shift_buffer_depth = get_duration_insec(s, (const char *)val);
-            } else if (!av_strcasecmp(attr->name, (const char *)"minBufferTime")) {
-                c->min_buffer_time = get_duration_insec(s, (const char *)val);
-            } else if (!av_strcasecmp(attr->name, (const char *)"suggestedPresentationDelay")) {
-                c->suggested_presentation_delay = get_duration_insec(s, (const char *)val);
-            } else if (!av_strcasecmp(attr->name, (const char *)"mediaPresentationDuration")) {
-                c->media_presentation_duration = get_duration_insec(s, (const char *)val);
-            }
+            if (!xmlStrcmp(attr->name, (const xmlChar *)"availabilityStartTime"))
+                c->availabilityStartTimeSec = GetUTCDateTimeInSec((const char *)val);
+            else if (!xmlStrcmp(attr->name, (const xmlChar *)"publishTime"))
+                c->publishTimeSec = GetUTCDateTimeInSec((const char *)val);
+            else if (!xmlStrcmp(attr->name, (const xmlChar *)"minimumUpdatePeriod"))
+                c->minimumUpdatePeriodSec = GetDurationInSec((const char *)val);
+            else if (!xmlStrcmp(attr->name, (const xmlChar *)"timeShiftBufferDepth"))
+                c->timeShiftBufferDepthSec = GetDurationInSec((const char *)val);
+            else if (!xmlStrcmp(attr->name, (const xmlChar *)"minBufferTime"))
+                c->minBufferTimeSec = GetDurationInSec((const char *)val);
+            else if (!xmlStrcmp(attr->name, (const xmlChar *)"suggestedPresentationDelay"))
+                c->suggestedPresentationDelaySec = GetDurationInSec((const char *)val);
+            else if (!xmlStrcmp(attr->name, (const xmlChar *)"mediaPresentationDuration"))
+                c->mediaPresentationDurationSec = GetDurationInSec((const char *)val);
+
             attr = attr->next;
+
             xmlFree(val);
         }
 
-        mpd_baseurl_node = find_child_node_by_name(node, "BaseURL");
+        mpdBaseUrlNode = findChildNodeByName(node, "BaseURL");
 
         // at now we can handle only one period, with the longest duration
         node = xmlFirstElementChild(node);
         while (node) {
-            if (!av_strcasecmp(node->name, (const char *)"Period")) {
-                perdiod_duration_sec = 0;
-                perdiod_start_sec = 0;
+            if (!xmlStrcmp(node->name, (const xmlChar *)"Period")) {
+                perdiodDurationSec = 0;
+                perdiodStartSec = 0;
                 attr = node->properties;
-                while (attr) {
+                while(attr) {
                     val = xmlGetProp(node, attr->name);
-                    if (!av_strcasecmp(attr->name, (const char *)"duration")) {
-                        perdiod_duration_sec = get_duration_insec(s, (const char *)val);
-                    } else if (!av_strcasecmp(attr->name, (const char *)"start")) {
-                        perdiod_start_sec = get_duration_insec(s, (const char *)val);
-                    }
+
+                    if (!xmlStrcmp(attr->name, (const xmlChar *)"duration"))
+                        perdiodDurationSec = GetDurationInSec((const char *)val);
+                    else if (!xmlStrcmp(attr->name, (const xmlChar *)"start"))
+                        perdiodStartSec = GetDurationInSec((const char *)val);
                     attr = attr->next;
+
                     xmlFree(val);
                 }
-                if ((perdiod_duration_sec) >= (c->period_duration)) {
-                    period_node = node;
-                    c->period_duration = perdiod_duration_sec;
-                    c->period_start = perdiod_start_sec;
-                    if (c->period_start > 0)
-                        c->media_presentation_duration = c->period_duration;
+
+                if ((perdiodDurationSec) >= (c->periodDurationSec)) {
+                    periodNode = node;
+                    c->periodDurationSec = perdiodDurationSec;
+                    c->periodStartSec = perdiodStartSec;
+                    if (c->periodStartSec > 0)
+                        c->mediaPresentationDurationSec = c->periodDurationSec;
                 }
             }
+
             node = xmlNextElementSibling(node);
         }
-        if (!period_node) {
+
+        if (!periodNode) {
             av_log(s, AV_LOG_ERROR, "Unable to parse '%s' - missing Period node\n", url);
             ret = AVERROR_INVALIDDATA;
             goto cleanup;
         }
 
-        adaptionset_node = xmlFirstElementChild(period_node);
-        while (adaptionset_node) {
-            if (!av_strcasecmp(adaptionset_node->name, (const char *)"BaseURL")) {
-                period_baseurl_node = adaptionset_node;
-            } else if (!av_strcasecmp(adaptionset_node->name, (const char *)"AdaptationSet")) {
-                parse_manifest_adaptationset(s, url, adaptionset_node, mpd_baseurl_node, period_baseurl_node);
+        // explore AdaptationSet
+        adaptionSetNode = xmlFirstElementChild(periodNode);
+        while (adaptionSetNode) {
+            if (!xmlStrcmp(adaptionSetNode->name, (const xmlChar *)"BaseURL")) {
+                periodBaseUrlNode = adaptionSetNode;
+            } else if (!xmlStrcmp(adaptionSetNode->name, (const xmlChar *)"SegmentList")) {
+                periodSegmentListNode = adaptionSetNode;
+            } else if (!xmlStrcmp(adaptionSetNode->name, (const xmlChar *)"AdaptationSet")) {
+                xmlNodePtr segmentTemplateNode = NULL;
+                xmlNodePtr contentComponentNode = NULL;
+                xmlNodePtr adaptionSetBaseUrlNode = NULL;
+                xmlNodePtr adaptionSetSegmentListNode = NULL;
+
+                node = xmlFirstElementChild(adaptionSetNode);
+                while (node) {
+                    if (!xmlStrcmp(node->name, (const xmlChar *)"SegmentTemplate")) {
+                        segmentTemplateNode = node;
+                    } else if (!xmlStrcmp(node->name, (const xmlChar *)"ContentComponent")) {
+                        contentComponentNode = node;
+                    } else if (!xmlStrcmp(node->name, (const xmlChar *)"BaseURL")) {
+                        adaptionSetBaseUrlNode = node;
+                    } else if (!xmlStrcmp(node->name, (const xmlChar *)"SegmentList")) {
+                        adaptionSetSegmentListNode = node;
+                    } else if (!xmlStrcmp(node->name, (const xmlChar *)"Representation")) {
+                        xmlNodePtr representationNode = node;
+                        xmlChar *rep_id_val = xmlGetProp(representationNode, "id");
+                        xmlChar *rep_bandwidth_val = xmlGetProp(representationNode, "bandwidth");
+                        enum RepType type = REP_TYPE_UNSPECIFIED;
+
+
+                        // try get information from representation
+                        if (type == REP_TYPE_UNSPECIFIED)
+                            type = get_content_type(representationNode);
+                        // try get information from contentComponen
+                        if (type == REP_TYPE_UNSPECIFIED)
+                            type = get_content_type(contentComponentNode);
+                        // try get information from adaption set
+                        if (type == REP_TYPE_UNSPECIFIED)
+                            type = get_content_type(adaptionSetNode);
+
+                        if (type == REP_TYPE_UNSPECIFIED) {
+                            av_log(s, AV_LOG_VERBOSE, "Parsing '%s' - skipp not supported representation type\n", url);
+                        } else if ( (type == REP_TYPE_VIDEO && ((c->video_rep_index < 0 && !c->cur_video) || videoRepIdx == (int32_t)c->video_rep_index )) || 
+                                    (type == REP_TYPE_AUDIO && ((c->audio_rep_index < 0 && !c->cur_audio) || audioRepIdx == (int32_t)c->audio_rep_index )) ) {
+
+                            // convert selected representation to our internal struct
+                            struct representation *rep = av_mallocz(sizeof(struct representation));
+                            xmlNodePtr representationSegmentTemplateNode = findChildNodeByName(representationNode, "SegmentTemplate");
+                            xmlNodePtr representationBaseUrlNode = findChildNodeByName(representationNode, "BaseURL");
+                            xmlNodePtr representationSegmentListNode = findChildNodeByName(representationNode, "SegmentList");
+                            reset_packet(&rep->pkt);
+                            if (representationSegmentTemplateNode || segmentTemplateNode) {
+
+                                xmlNodePtr segmentTemplatesTab[2] = {representationSegmentTemplateNode, segmentTemplateNode};
+                                xmlChar *duration_val        = get_val_from_nodes_tab(segmentTemplatesTab,  2, "duration");
+                                xmlChar *startNumber_val     = get_val_from_nodes_tab(segmentTemplatesTab,  2, "startNumber");
+                                xmlChar *timescale_val       = get_val_from_nodes_tab(segmentTemplatesTab,  2, "timescale");
+
+                                xmlChar *initialization_val  = get_val_from_nodes_tab(segmentTemplatesTab,  2, "initialization");
+                                xmlChar *media_val           = get_val_from_nodes_tab(segmentTemplatesTab,  2, "media");
+
+                                xmlNodePtr baseUrlNodes[4] = {mpdBaseUrlNode, periodBaseUrlNode, adaptionSetBaseUrlNode, representationBaseUrlNode};
+
+                                if (initialization_val) {
+                                    rep->init_section = av_mallocz(sizeof(struct segment));
+                                    rep->init_section->url = get_content_url(baseUrlNodes, 4, rep_id_val, rep_bandwidth_val, initialization_val);
+                                    rep->init_section->size = -1;
+                                    xmlFree(initialization_val);
+                                }
+
+                                if (media_val) {
+                                    char *tmp_str = get_content_url(baseUrlNodes, 4, rep_id_val, rep_bandwidth_val, media_val);
+                                    rep->tmp_url_type = TMP_URL_TYPE_UNSPECIFIED;
+                                    if (tmp_str) {
+                                        rep->url_template = tmp_str;
+
+                                        if (strstr(tmp_str, "$Number") && 
+                                            0 == get_repl_pattern_and_format(tmp_str, "$Number$", &(rep->url_template_pattern), &(rep->url_template_format))) {
+                                            //  A URL template is provided from which clients build a chunk list where the chunk URLs include chunk numbers (like index numbers).
+                                            rep->tmp_url_type = TMP_URL_TYPE_NUMBER; // (Chunk) Number-Based.
+                                        } else if (strstr(tmp_str, "$Time") &&
+                                                   0 == get_repl_pattern_and_format(tmp_str, "$Time$", &(rep->url_template_pattern), &(rep->url_template_format))) {
+                                            // A URL template is provided from which clients build a chunk list where the chunk URLs include chunk start times.
+                                            rep->tmp_url_type = TMP_URL_TYPE_TIME; // (CTime-Based.
+                                        }
+                                    }
+                                    xmlFree(media_val);
+                                }
+
+                                if (duration_val) {
+                                    rep->segmentDuration = (int64_t) atoll((const char *)duration_val);
+                                    xmlFree(duration_val);
+                                }
+                                
+                                if (timescale_val) {
+                                    rep->segmentTimescalce = (int64_t) atoll((const char *)timescale_val);
+                                    xmlFree(timescale_val);
+                                }
+
+                                if (startNumber_val) {
+                                    rep->first_seq_no = (int64_t) atoll((const char *)startNumber_val);
+                                    xmlFree(startNumber_val);
+                                }
+
+                                fill_timelines(rep, segmentTemplatesTab, 2);
+                            } else if (representationBaseUrlNode && !representationSegmentListNode) {
+                                xmlNodePtr baseUrlNodes[4] = {mpdBaseUrlNode, periodBaseUrlNode, adaptionSetBaseUrlNode, representationBaseUrlNode};
+                                struct segment *seg = av_mallocz(sizeof(struct segment));
+                                seg->url = get_content_url(baseUrlNodes, 4, rep_id_val, rep_bandwidth_val, NULL);
+                                seg->size = -1;
+                                dynarray_add(&rep->segments, &rep->n_segments, seg);
+                            } else if (representationSegmentListNode) {
+                               // TODO: https://www.brendanlong.com/the-structure-of-an-mpeg-dash-mpd.html
+                               // http://www-itec.uni-klu.ac.at/dash/ddash/mpdGenerator.php?segmentlength=15&type=full
+                                xmlNodePtr segmentUrlNode = NULL;
+                                xmlNodePtr segmentListTab[3] = {representationSegmentListNode, adaptionSetSegmentListNode, periodSegmentListNode};
+                                xmlChar *duration_val        = get_val_from_nodes_tab(segmentListTab,  3, "duration");
+                                xmlChar *startNumber_val     = get_val_from_nodes_tab(segmentListTab,  3, "startNumber");
+                                xmlChar *timescale_val       = get_val_from_nodes_tab(segmentListTab,  3, "timescale");
+
+                                if (duration_val) {
+                                    rep->segmentDuration = (int64_t) atoll((const char *)duration_val);
+                                    xmlFree(duration_val);
+                                }
+
+                                if (timescale_val) {
+                                    rep->segmentTimescalce = (int64_t) atoll((const char *)timescale_val);
+                                    xmlFree(timescale_val);
+                                }
+
+                                if (startNumber_val) {
+                                    rep->start_number = (int64_t) atoll((const char *)startNumber_val);
+                                    xmlFree(startNumber_val);
+                                }
+
+                                segmentUrlNode = xmlFirstElementChild(representationSegmentListNode);
+                                while (segmentUrlNode) {
+                                    if (!xmlStrcmp(segmentUrlNode->name, (const xmlChar *)"Initialization")) {
+                                        xmlChar *initialization_val = xmlGetProp(segmentUrlNode, "sourceURL");
+                                        if (initialization_val) {
+                                            xmlNodePtr baseUrlNodes[4] = {mpdBaseUrlNode, periodBaseUrlNode, adaptionSetBaseUrlNode, representationBaseUrlNode};
+                                            rep->init_section = av_mallocz(sizeof(struct segment));
+                                            rep->init_section->url = get_content_url(baseUrlNodes, 4, rep_id_val, rep_bandwidth_val, initialization_val);
+                                            rep->init_section->size = -1;
+                                            xmlFree(initialization_val);
+                                        }
+                                    } else if (!xmlStrcmp(segmentUrlNode->name, (const xmlChar *)"SegmentURL")) {
+                                        xmlChar *media_val = xmlGetProp(segmentUrlNode, "media");
+                                        if (media_val) {
+                                            xmlNodePtr baseUrlNodes[4] = {mpdBaseUrlNode, periodBaseUrlNode, adaptionSetBaseUrlNode, representationBaseUrlNode};
+                                            struct segment *seg = av_mallocz(sizeof(struct segment));
+                                            seg->url = get_content_url(baseUrlNodes, 4, rep_id_val, rep_bandwidth_val, media_val);
+                                            seg->size = -1;
+                                            dynarray_add(&rep->segments, &rep->n_segments, seg);
+                                            xmlFree(media_val);
+                                        }
+                                    }
+                                    segmentUrlNode = xmlNextElementSibling(segmentUrlNode);
+                                }
+
+                                fill_timelines(rep, segmentListTab, 2);
+                            } else {
+                                free_representation(rep);
+                                rep = NULL;
+                                av_log(s, AV_LOG_ERROR, "Unknown format of Representation node id[%s] \n", (const char *)rep_id_val);
+                            }
+
+                            if (rep) {
+                                if (rep->segmentDuration > 0 && rep->segmentTimescalce == 0)
+                                    rep->segmentTimescalce = 1;
+
+                                if (type == REP_TYPE_VIDEO) {
+                                    rep->rep_idx = videoRepIdx;
+                                    c->cur_video = rep;
+                                }
+                                else {
+                                    rep->rep_idx = audioRepIdx;
+                                    c->cur_audio = rep;
+                                }
+                            }
+                        }
+
+                        if (type == REP_TYPE_VIDEO) {
+                            videoRepIdx += 1;
+                        } if (type == REP_TYPE_AUDIO) {
+                            audioRepIdx += 1;
+                        }
+
+                        if (rep_id_val)
+                            xmlFree(rep_id_val);
+                        
+                        if (rep_bandwidth_val)
+                            xmlFree(rep_bandwidth_val);
+                    }
+                    node = xmlNextElementSibling(node);
+                }
             }
-            adaptionset_node = xmlNextElementSibling(adaptionset_node);
+            adaptionSetNode = xmlNextElementSibling(adaptionSetNode);
         }
+
         if (c->cur_video) {
-            c->cur_video->rep_count = video_rep_idx;
+            c->cur_video->rep_count = videoRepIdx;
+            c->cur_video->fix_multiple_stsd_order = 1;
+            
             av_log(s, AV_LOG_VERBOSE, "rep_idx[%d]\n", (int)c->cur_video->rep_idx);
-            av_log(s, AV_LOG_VERBOSE, "rep_count[%d]\n", (int)video_rep_idx);
+            av_log(s, AV_LOG_VERBOSE, "rep_count[%d]\n", (int)videoRepIdx);
         }
+        
         if (c->cur_audio) {
-            c->cur_audio->rep_count = audio_rep_idx;
+            c->cur_audio->rep_count = audioRepIdx;
         }
+
 cleanup:
         /*free the document */
         xmlFreeDoc(doc);
         xmlCleanupParser();
+
+    } else {
+        av_log(s, AV_LOG_ERROR, "Unable to read to offset '%s'\n", url);
+        ret = AVERROR_INVALIDDATA;
     }
 
     av_free(new_url);
@@ -1032,82 +1048,84 @@ cleanup:
     return ret;
 }
 
-static int64_t calc_cur_seg_no(AVFormatContext *s, struct representation *pls)
+/////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////
+static int64_t get_segment_start_time_based_on_timeline(struct representation *pls, int64_t cur_seq_no)
 {
-    DASHContext *c = s->priv_data;
-    int64_t num = 0;
-    int64_t start_time_offset = 0;
+    int64_t startTime = 0;
+    if (pls->n_timelines) {
+        int64_t i = 0;
+        int64_t j = 0;
+        int64_t num = 0;
 
-    if (c->is_live) {
-        if (pls->n_fragments) {
-            num = pls->first_seq_no;
-        } else if (pls->n_timelines) {
-            start_time_offset = get_segment_start_time_based_on_timeline(pls, 0xFFFFFFFF) - pls->timelines[pls->first_seq_no]->starttime; // total duration of playlist
-            if (start_time_offset < 60 * pls->fragment_timescale)
-                start_time_offset = 0;
-            else
-                start_time_offset = start_time_offset - 60 * pls->fragment_timescale;
+        for (i=0; i<pls->n_timelines; ++i) {
+            if (pls->timelines[i]->t > 0) {
+                startTime = pls->timelines[i]->t;
+            }
 
-            num = calc_next_seg_no_from_timelines(pls, pls->timelines[pls->first_seq_no]->starttime + start_time_offset);
-            if (num == -1)
-                num = pls->first_seq_no;
-        } else if (pls->fragment_duration){
-            if (pls->presentation_timeoffset) {
-                num = pls->presentation_timeoffset * pls->fragment_timescale / pls->fragment_duration;
-            } else if (c->publish_time > 0 && !c->availability_start_time) {
-                num = pls->first_seq_no + (((c->publish_time - c->availability_start_time) - c->suggested_presentation_delay) * pls->fragment_timescale) / pls->fragment_duration;
-            } else {
-                num = pls->first_seq_no + (((get_current_time_in_sec() - c->availability_start_time) - c->suggested_presentation_delay) * pls->fragment_timescale) / pls->fragment_duration;
+            if (num == cur_seq_no)
+                goto finish;
+
+            startTime += pls->timelines[i]->d;
+
+            for (j = 0; j < pls->timelines[i]->r; ++j) {
+                num += 1;
+                if (num == cur_seq_no)
+                    goto finish;
+                startTime += pls->timelines[i]->d;
             }
+            num += 1;
+
         }
-    } else {
-        num = pls->first_seq_no;
     }
-    return num;
+finish:
+    return startTime;
 }
 
-static int64_t calc_min_seg_no(AVFormatContext *s, struct representation *pls)
+static int64_t calc_next_seg_no_from_timelines(struct representation *pls, int64_t currentTime)
 {
-    DASHContext *c = s->priv_data;
+    int64_t i = 0;
+    int64_t j = 0;
     int64_t num = 0;
+    int64_t startTime = 0;
 
-    if (c->is_live && pls->fragment_duration) {
-        num = pls->first_seq_no + (((get_current_time_in_sec() - c->availability_start_time) - c->time_shift_buffer_depth) * pls->fragment_timescale) / pls->fragment_duration;
-    } else {
-        num = pls->first_seq_no;
-    }
-    return num;
-}
-
-static int64_t calc_max_seg_no(struct representation *pls, DASHContext *c)
-{
-    int64_t num = 0;
+    for (i=0; i<pls->n_timelines; ++i) {
+        if (pls->timelines[i]->t > 0) {
+            startTime = pls->timelines[i]->t;
+        }
 
-    if (pls->n_fragments) {
-        num = pls->first_seq_no + pls->n_fragments - 1;
-    } else if (pls->n_timelines) {
-        int i = 0;
-        num = pls->first_seq_no + pls->n_timelines - 1;
-        for (i = 0; i < pls->n_timelines; i++) {
-            num += pls->timelines[i]->repeat;
+        if (startTime > currentTime)
+            goto finish;
+        
+        startTime += pls->timelines[i]->d;
+        
+        for (j = 0; j < pls->timelines[i]->r; ++j) {
+            num += 1;
+            if (startTime > currentTime)
+                goto finish;
+            startTime += pls->timelines[i]->d;
         }
-    } else if (c->is_live && pls->fragment_duration) {
-        num = pls->first_seq_no + (((get_current_time_in_sec() - c->availability_start_time)) * pls->fragment_timescale)  / pls->fragment_duration;
-    } else if (pls->fragment_duration) {
-        num = pls->first_seq_no + (c->media_presentation_duration * pls->fragment_timescale) / pls->fragment_duration;
+        num += 1;
     }
 
+    return -1;
+
+finish:
     return num;
 }
 
+static int64_t calc_max_seg_no(struct representation *pls, DASHContext *c);
+
 static void move_timelines(struct representation *rep_src, struct representation *rep_dest, DASHContext *c)
 {
-    if (rep_dest && rep_src ) {
+    if (rep_dest != NULL && rep_src != NULL) {
         free_timelines_list(rep_dest);
         rep_dest->timelines    = rep_src->timelines;
         rep_dest->n_timelines  = rep_src->n_timelines;
         rep_dest->first_seq_no = rep_src->first_seq_no;
+
         rep_dest->last_seq_no = calc_max_seg_no(rep_dest, c);
+
         rep_src->timelines = NULL;
         rep_src->n_timelines = 0;
         rep_dest->cur_seq_no = rep_src->cur_seq_no;
@@ -1116,29 +1134,32 @@ static void move_timelines(struct representation *rep_src, struct representation
 
 static void move_segments(struct representation *rep_src, struct representation *rep_dest, DASHContext *c)
 {
-    if (rep_dest && rep_src ) {
-        free_fragment_list(rep_dest);
-        if (rep_src->start_number > (rep_dest->start_number + rep_dest->n_fragments))
+    if (rep_dest != NULL && rep_src != NULL) {
+
+        free_segment_list(rep_dest);
+        
+        if (rep_src->start_number > (rep_dest->start_number + rep_dest->cur_seq_no))
             rep_dest->cur_seq_no = 0;
         else
-            rep_dest->cur_seq_no += rep_src->start_number - rep_dest->start_number;
-        rep_dest->fragments    = rep_src->fragments;
-        rep_dest->n_fragments  = rep_src->n_fragments;
-        rep_dest->parent  = rep_src->parent;
+            rep_dest->cur_seq_no = rep_src->n_segments - ((rep_src->start_number + rep_src->n_segments) - (rep_dest->start_number + rep_dest->cur_seq_no));
+        
+        rep_dest->segments    = rep_src->segments;
+        rep_dest->n_segments  = rep_src->n_segments;
+        rep_dest->start_number = rep_src->start_number;
+
         rep_dest->last_seq_no = calc_max_seg_no(rep_dest, c);
-        rep_src->fragments = NULL;
-        rep_src->n_fragments = 0;
+
+        rep_src->segments = NULL;
+        rep_src->n_segments = 0;
     }
 }
 
-
 static int refresh_manifest(AVFormatContext *s)
 {
-
     int ret = 0;
     DASHContext *c = s->priv_data;
 
-    // save current context
+    // save current context 
     struct representation *cur_video =  c->cur_video;
     struct representation *cur_audio =  c->cur_audio;
     char *base_url = c->base_url;
@@ -1146,36 +1167,42 @@ static int refresh_manifest(AVFormatContext *s)
     c->base_url = NULL;
     c->cur_video = NULL;
     c->cur_audio = NULL;
-    ret = parse_manifest(s, s->filename, NULL);
-    if (ret)
+    
+    ret = parse_mainifest(s, s->filename, NULL);
+    if (ret != 0)
         goto finish;
 
-    if (cur_video && cur_video->timelines || cur_audio && cur_audio->timelines) {
-        // calc current time
+    if (cur_video && cur_video->timelines || cur_audio && cur_audio->timelines)
+    {
+        // calc current time 
         int64_t currentVideoTime = 0;
         int64_t currentAudioTime = 0;
+
         if (cur_video && cur_video->timelines)
-            currentVideoTime = get_segment_start_time_based_on_timeline(cur_video, cur_video->cur_seq_no) / cur_video->fragment_timescale;
+            currentVideoTime = get_segment_start_time_based_on_timeline(cur_video, cur_video->cur_seq_no) / cur_video->segmentTimescalce;
+
         if (cur_audio && cur_audio->timelines)
-            currentAudioTime = get_segment_start_time_based_on_timeline(cur_audio, cur_audio->cur_seq_no) / cur_audio->fragment_timescale;
+            currentAudioTime = get_segment_start_time_based_on_timeline(cur_audio, cur_audio->cur_seq_no) / cur_audio->segmentTimescalce;
+
         // update segments
         if (cur_video && cur_video->timelines) {
-            c->cur_video->cur_seq_no = calc_next_seg_no_from_timelines(c->cur_video, currentVideoTime * cur_video->fragment_timescale - 1);
-            if (c->cur_video->cur_seq_no >= 0) {
+            c->cur_video->cur_seq_no = calc_next_seg_no_from_timelines(c->cur_video, currentVideoTime * cur_video->segmentTimescalce - 1);
+            if (c->cur_video->cur_seq_no >= 0)
                 move_timelines(c->cur_video, cur_video, c);
-            }
         }
+        
         if (cur_audio && cur_audio->timelines) {
-            c->cur_audio->cur_seq_no = calc_next_seg_no_from_timelines(c->cur_audio, currentAudioTime * cur_audio->fragment_timescale - 1);
-            if (c->cur_audio->cur_seq_no >= 0) {
-               move_timelines(c->cur_audio, cur_audio, c);
-            }
+            c->cur_audio->cur_seq_no = calc_next_seg_no_from_timelines(c->cur_audio, currentAudioTime * cur_audio->segmentTimescalce - 1);
+            if (c->cur_audio->cur_seq_no >= 0)
+                move_timelines(c->cur_audio, cur_audio, c);
         }
     }
-    if (cur_video && cur_video->fragments) {
+
+    if (cur_video && cur_video->segments) {
         move_segments(c->cur_video, cur_video, c);
     }
-    if (cur_audio && cur_audio->fragments) {
+
+    if (cur_audio && cur_audio->segments) {
         move_segments(c->cur_audio, cur_audio, c);
     }
 
@@ -1185,84 +1212,147 @@ finish:
         av_free(base_url);
     else
         c->base_url  = base_url;
+
     if (c->cur_audio)
         free_representation(c->cur_audio);
+
     if (c->cur_video)
         free_representation(c->cur_video);
+
     c->cur_audio = cur_audio;
     c->cur_video = cur_video;
+    
     return ret;
 }
 
-static struct fragment *get_current_fragment(struct representation *pls)
+
+static int64_t calc_cur_seg_no(struct representation *pls, DASHContext *c)
+{
+    int64_t num = 0;
+    if (c->is_live) {
+        if (pls->n_segments) {
+            // handle segment number here
+            num = pls->first_seq_no;
+        } else if (pls->n_timelines) {
+            int64_t startTimeOffset = get_segment_start_time_based_on_timeline(pls, 0xFFFFFFFF) - pls->timelines[pls->first_seq_no]->t; // total duration of playlist
+            if (startTimeOffset < 60*pls->segmentTimescalce)
+                startTimeOffset = 0;
+            else
+                startTimeOffset = startTimeOffset - 60*pls->segmentTimescalce;
+
+            num = calc_next_seg_no_from_timelines(pls, pls->timelines[pls->first_seq_no]->t + startTimeOffset);
+            if (num == -1)
+                num = pls->first_seq_no;
+        }
+        else {
+            num = pls->first_seq_no + (((GetCurrentTimeInSec() - c->availabilityStartTimeSec) - c->presentationDelaySec) * pls->segmentTimescalce) / pls->segmentDuration;
+        }
+    } else {
+        num = pls->first_seq_no;
+    }
+    return num;
+}
+
+static int64_t calc_min_seg_no(struct representation *pls, DASHContext *c)
+{
+    int64_t num = 0;
+    if (c->is_live && pls->segmentDuration) { 
+        num = pls->first_seq_no + (((GetCurrentTimeInSec() - c->availabilityStartTimeSec) - c->timeShiftBufferDepthSec) * pls->segmentTimescalce)  / pls->segmentDuration;
+    } else {
+        num = pls->first_seq_no;
+    }
+    return num;
+}
+
+static int64_t calc_max_seg_no(struct representation *pls, DASHContext *c)
+{
+    int64_t num = 0;
+
+    if (pls->n_segments) {
+        num = pls->first_seq_no + pls->n_segments - 1;
+    } else if (pls->n_timelines) {
+        int i = 0;
+        num = pls->first_seq_no + pls->n_timelines - 1;
+        for (i=0; i<pls->n_timelines; ++i) {
+            num += pls->timelines[i]->r;
+        }
+    }
+    else if (c->is_live) {
+        num = pls->first_seq_no + (((GetCurrentTimeInSec() - c->availabilityStartTimeSec)) * pls->segmentTimescalce)  / pls->segmentDuration;
+    }
+    else {
+        num = pls->first_seq_no + (c->mediaPresentationDurationSec * pls->segmentTimescalce) / pls->segmentDuration;
+    }
+
+    return num;
+}
+
+static struct segment *get_current_segment(struct representation *pls)
 {
-    int64_t min_seq_no = 0;
-    int64_t max_seq_no = 0;
-    struct fragment *seg = NULL;
-    struct fragment *seg_ptr = NULL;
+    struct segment *seg = NULL;
     DASHContext *c = pls->parent->priv_data;
 
-    while (( !ff_check_interrupt(c->interrupt_callback)&& pls->n_fragments > 0)) {
-        if (pls->cur_seq_no < pls->n_fragments) {
-            seg_ptr = pls->fragments[pls->cur_seq_no];
-            seg = av_mallocz(sizeof(struct fragment));
-            if (!seg) {
-                return NULL;
-            }
+    while (!ff_check_interrupt(c->interrupt_callback) && pls->n_segments > 0) {
+        if (pls->cur_seq_no < pls->n_segments) {
+            struct segment *seg_ptr = pls->segments[pls->cur_seq_no];
+            seg = av_mallocz(sizeof(struct segment));
             seg->url = av_strdup(seg_ptr->url);
-            if (!seg->url) {
-                av_free(seg);
-                return NULL;
-            }
             seg->size = seg_ptr->size;
             seg->url_offset = seg_ptr->url_offset;
             return seg;
         } else if (c->is_live) {
+            sleep(2);
             refresh_manifest(pls->parent);
-        } else {
+        } else
             break;
-        }
     }
-    if (c->is_live) {
-        min_seq_no = calc_min_seg_no(pls->parent, pls);
-        max_seq_no = calc_max_seg_no(pls, c);
 
-        if (pls->timelines || pls->fragments) {
-            refresh_manifest(pls->parent);
-        }
-        if (pls->cur_seq_no <= min_seq_no) {
-            av_log(pls->parent, AV_LOG_VERBOSE, "old fragment: cur[%"PRId64"] min[%"PRId64"] max[%"PRId64"], playlist %d\n", (int64_t)pls->cur_seq_no, min_seq_no, max_seq_no, (int)pls->rep_idx);
-            pls->cur_seq_no = calc_cur_seg_no(pls->parent, pls);
-        } else if (pls->cur_seq_no > max_seq_no) {
-            av_log(pls->parent, AV_LOG_VERBOSE, "new fragment: min[%"PRId64"] max[%"PRId64"], playlist %d\n", min_seq_no, max_seq_no, (int)pls->rep_idx);
-        }
-        seg = av_mallocz(sizeof(struct fragment));
-        if (!seg) {
-            return NULL;
+    if (c->is_live) {
+        while (!ff_check_interrupt(c->interrupt_callback)) {
+            int64_t min_seq_no = calc_min_seg_no(pls, c);
+            int64_t max_seq_no = calc_max_seg_no(pls, c);
+            
+            if (pls->cur_seq_no <= min_seq_no) {
+                av_log(pls->parent, AV_LOG_VERBOSE, "%s to old segment: cur[%"PRId64"] min[%"PRId64"] max[%"PRId64"], playlist %d\n", __FUNCTION__, (int64_t)pls->cur_seq_no, min_seq_no, max_seq_no, (int)pls->rep_idx);
+                if (c->is_live && (pls->timelines || pls->segments)) {
+                    refresh_manifest(pls->parent);
+                }
+                pls->cur_seq_no = calc_cur_seg_no(pls, c);
+            } else if (pls->cur_seq_no > max_seq_no) {
+                av_log(pls->parent, AV_LOG_VERBOSE, "%s wait for new segment: min[%"PRId64"] max[%"PRId64"], playlist %d\n", __FUNCTION__, min_seq_no, max_seq_no, (int)pls->rep_idx);
+                sleep(2);
+                if (c->is_live && (pls->timelines || pls->segments)) {
+                    refresh_manifest(pls->parent);
+                }
+                continue;
+            }
+            break;
         }
+        seg = av_mallocz(sizeof(struct segment));
     } else if (pls->cur_seq_no <= pls->last_seq_no) {
-        seg = av_mallocz(sizeof(struct fragment));
-        if (!seg) {
-            return NULL;
-        }
+        seg = av_mallocz(sizeof(struct segment));
     }
+
     if (seg) {
-        char tmpfilename[MAX_URL_SIZE];
+        if (pls->tmp_url_type != TMP_URL_TYPE_UNSPECIFIED) {
+            int64_t val = pls->tmp_url_type == TMP_URL_TYPE_NUMBER ? pls->cur_seq_no : get_segment_start_time_based_on_timeline(pls, pls->cur_seq_no);
+            int size = snprintf(NULL, 0, pls->url_template_format, val); // calc needed buffer size
+
+            if (size > 0) {
+                char *tmp_val = av_mallocz(size + 1);
+                snprintf(tmp_val, size+1, pls->url_template_format, val);
+                seg->url = repl_str(pls->url_template, pls->url_template_pattern, tmp_val);
+                av_free(tmp_val);
+            }
+        }
 
-        ff_dash_fill_tmpl_params(tmpfilename, sizeof(tmpfilename), pls->url_template, 0, pls->cur_seq_no, 0, get_segment_start_time_based_on_timeline(pls, pls->cur_seq_no));
-        seg->url = av_strireplace(pls->url_template, pls->url_template, tmpfilename);
         if (!seg->url) {
-            av_log(pls->parent, AV_LOG_WARNING, "Unable to resolve template url '%s', try to use origin template\n", pls->url_template);
+            av_log(pls->parent, AV_LOG_ERROR, "Unable to resolve template url '%s'\n", pls->url_template);
             seg->url = av_strdup(pls->url_template);
-            if (!seg->url) {
-                av_log(pls->parent, AV_LOG_ERROR, "Cannot resolve template url '%s'\n", pls->url_template);
-                return NULL;
-            }
         }
-
         seg->size = -1;
     }
-
+    
     return seg;
 }
 
@@ -1271,37 +1361,45 @@ enum ReadFromURLMode {
     READ_COMPLETE,
 };
 
-static int read_from_url(struct representation *pls, struct fragment *seg,
+static int read_from_url(struct representation *pls, struct segment *seg,
                          uint8_t *buf, int buf_size,
                          enum ReadFromURLMode mode)
 {
     int ret;
 
-    /* limit read if the fragment was only a part of a file */
+     /* limit read if the segment was only a part of a file */
     if (seg->size >= 0)
         buf_size = FFMIN(buf_size, pls->cur_seg_size - pls->cur_seg_offset);
 
     if (mode == READ_COMPLETE) {
         ret = avio_read(pls->input, buf, buf_size);
-        if (ret < buf_size) {
-            av_log(pls->parent, AV_LOG_WARNING, "Could not read complete fragment.\n");
-        }
-    } else {
+        if (ret != buf_size)
+            av_log(NULL, AV_LOG_ERROR, "Could not read complete segment buf_size[%d] ret[%d].\n", buf_size, ret);
+    } else if (buf_size > 0)
         ret = avio_read(pls->input, buf, buf_size);
-    }
+    else
+        ret = AVERROR_EOF;
+
     if (ret > 0)
         pls->cur_seg_offset += ret;
 
     return ret;
 }
 
-static int open_input(DASHContext *c, struct representation *pls, struct fragment *seg)
+static int open_input(DASHContext *c, struct representation *pls, struct segment *seg)
 {
     AVDictionary *opts = NULL;
     char url[MAX_URL_SIZE];
     int ret;
 
-    set_httpheader_options(c, &opts);
+    // broker prior HTTP options that should be consistent across requests
+    av_dict_set(&opts, "user-agent", c->user_agent, 0);
+    av_dict_set(&opts, "cookies", c->cookies, 0);
+    av_dict_set(&opts, "headers", c->headers, 0);
+    if (c->is_live) {
+        av_dict_set(&opts, "seekable", "0", 0);
+    }
+
     if (seg->size >= 0) {
         /* try to restrict the HTTP request to the part we want
          * (if this is in fact a HTTP request) */
@@ -1310,8 +1408,10 @@ static int open_input(DASHContext *c, struct representation *pls, struct fragmen
     }
 
     ff_make_absolute_url(url, MAX_URL_SIZE, c->base_url, seg->url);
+
     av_log(pls->parent, AV_LOG_VERBOSE, "DASH request for url '%s', offset %"PRId64", playlist %d\n",
            url, seg->url_offset, pls->rep_idx);
+
     ret = open_url(pls->parent, &pls->input, url, c->avio_opts, opts, NULL);
     if (ret < 0) {
         goto cleanup;
@@ -1320,10 +1420,10 @@ static int open_input(DASHContext *c, struct representation *pls, struct fragmen
     /* Seek to the requested position. If this was a HTTP request, the offset
      * should already be where want it to, but this allows e.g. local testing
      * without a HTTP server. */
-    if (!ret && seg->url_offset) {
+    if (ret == 0 && seg->url_offset) {
         int64_t seekret = avio_seek(pls->input, seg->url_offset, SEEK_SET);
         if (seekret < 0) {
-            av_log(pls->parent, AV_LOG_ERROR, "Unable to seek to offset %"PRId64" of DASH fragment '%s'\n", seg->url_offset, seg->url);
+            av_log(pls->parent, AV_LOG_ERROR, "Unable to seek to offset %"PRId64" of DASH segment '%s'\n", seg->url_offset, seg->url);
             ret = (int) seekret;
             ff_format_io_close(pls->parent, &pls->input);
         }
@@ -1338,14 +1438,16 @@ cleanup:
 
 static int update_init_section(struct representation *pls)
 {
-    static const int max_init_section_size = 1024 * 1024;
+    static const int max_init_section_size = 1024*1024;
     DASHContext *c = pls->parent->priv_data;
     int64_t sec_size;
     int64_t urlsize;
     int ret;
 
-    if (!pls->init_section || pls->init_sec_buf)
+    /* read init section only once per representation */
+    if (!pls->init_section || pls->init_sec_buf) {
         return 0;
+    }
 
     ret = open_input(c, pls, pls->init_section);
     if (ret < 0) {
@@ -1376,7 +1478,63 @@ static int update_init_section(struct representation *pls)
 
     if (ret < 0)
         return ret;
+    if (pls->fix_multiple_stsd_order && pls->rep_idx > 0) {
+        uint8_t **stsd_entries = NULL;
+        int *stsd_entries_size = NULL;
+
+        int i = 4;
+        while(i <= ret-4) {
+            // find start stsd atom
+            if (0 == memcmp(pls->init_sec_buf + i, "stsd", 4)) {
+                // 1B version
+                // 3B flags
+                // 4B num of entries
+                int stsd_first_offset = i + 8;
+                int stsd_offset = 0;
+                int j = 0;
+                uint32_t stsd_count = AV_RB32(pls->init_sec_buf + stsd_first_offset);
+                stsd_first_offset += 4;
+                if (stsd_count != pls->rep_count) {
+                    i += 1;
+                    continue;
+                }
+
+                // find all stsd entries
+                stsd_entries = av_mallocz_array(stsd_count, sizeof(*stsd_entries));
+                stsd_entries_size = av_mallocz_array(stsd_count, sizeof(*stsd_entries_size));
+                for (j=0; j<stsd_count; ++j) {
+                    // 4B - size
+                    // 4B - format
+                    stsd_entries_size[j] = AV_RB32(pls->init_sec_buf + stsd_first_offset + stsd_offset);
+                    stsd_entries[j] = av_malloc(stsd_entries_size[j]);
+                    memcpy(stsd_entries[j], pls->init_sec_buf + stsd_first_offset + stsd_offset, stsd_entries_size[j]);
+                    stsd_offset += stsd_entries_size[j];
+                }
+
+                // reorder stsd entries
+                // as first put stsd entry for current representation
+                j = pls->rep_idx;
+                stsd_offset = stsd_first_offset;
+                memcpy(pls->init_sec_buf + stsd_offset, stsd_entries[j], stsd_entries_size[j]);
+                stsd_offset += stsd_entries_size[j];
+
+                for (j=0; j<stsd_count; ++j) {
+                    if (j != pls->rep_idx) {
+                        memcpy(pls->init_sec_buf + stsd_offset, stsd_entries[j], stsd_entries_size[j]);
+                        stsd_offset += stsd_entries_size[j];
+                    }
+                    av_free(stsd_entries[j]);
+                }
+
+                av_freep(&stsd_entries);
+                av_freep(&stsd_entries_size);
+                break;
+            }
+            i += 1;
+        }
+    }
 
+    av_log(pls->parent, AV_LOG_TRACE, "%s pls[%p] init section size[%d]\n", __FUNCTION__, pls, (int)ret);
     pls->init_sec_data_len = ret;
     pls->init_sec_buf_read_offset = 0;
 
@@ -1386,7 +1544,7 @@ static int update_init_section(struct representation *pls)
 static int64_t seek_data(void *opaque, int64_t offset, int whence)
 {
     struct representation *v = opaque;
-    if (v->n_fragments && !v->init_sec_data_len) {
+    if (v->n_segments == 1 && 0 == v->init_sec_data_len) {
         return avio_seek(v->input, offset, whence);
     }
 
@@ -1395,14 +1553,13 @@ static int64_t seek_data(void *opaque, int64_t offset, int whence)
 
 static int read_data(void *opaque, uint8_t *buf, int buf_size)
 {
-    int ret = 0;
     struct representation *v = opaque;
     DASHContext *c = v->parent->priv_data;
-
+    int ret = 0;
 restart:
     if (!v->input) {
-        free_fragment(&v->cur_seg);
-        v->cur_seg = get_current_fragment(v);
+        free_segment(&v->cur_seg);
+        v->cur_seg = get_current_segment(v);
         if (!v->cur_seg) {
             ret = AVERROR_EOF;
             goto end;
@@ -1419,14 +1576,21 @@ restart:
                 goto end;
                 ret = AVERROR_EXIT;
             }
-            av_log(v->parent, AV_LOG_WARNING, "Failed to open fragment of playlist %d\n", v->rep_idx);
-            v->cur_seq_no++;
+            av_log(v->parent, AV_LOG_WARNING, "Failed to open segment of playlist %d\n",
+                   v->rep_idx);
+            if (c->is_live && (v->timelines || v->segments)) {
+                // refresh_manifest(v->parent);
+                sleep(1);
+            }
+            else {
+                v->cur_seq_no += 1;
+            }
             goto restart;
         }
     }
 
     if (v->init_sec_buf_read_offset < v->init_sec_data_len) {
-        /* Push init section out first before first actual fragment */
+        /* Push init section out first before first actual segment */
         int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);
         memcpy(buf, v->init_sec_buf, copy_size);
         v->init_sec_buf_read_offset += copy_size;
@@ -1434,22 +1598,29 @@ restart:
         goto end;
     }
 
-    /* check the v->cur_seg, if it is null, get current and double check if the new v->cur_seg*/
     if (!v->cur_seg) {
-        v->cur_seg = get_current_fragment(v);
+        v->cur_seg = get_current_segment(v);
     }
+
     if (!v->cur_seg) {
         ret = AVERROR_EOF;
         goto end;
     }
+
     ret = read_from_url(v, v->cur_seg, buf, buf_size, READ_NORMAL);
     if (ret > 0)
         goto end;
 
+    /* This is needed to free indexes from previously processed segments.
+     * Maybe we should restart context every few segments?
+     */
     if (!v->is_restart_needed)
-        v->cur_seq_no++;
+        v->cur_seq_no += 1;
     v->is_restart_needed = 1;
-
+
+    // ff_format_io_close(v->parent, &v->input);
+    // v->cur_seq_no += 1;
+    // goto restart;
 end:
     return ret;
 }
@@ -1463,8 +1634,9 @@ static int save_avio_options(AVFormatContext *s)
 
     while (*opt) {
         if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN, &buf) >= 0) {
-            if (buf[0] != '\0') {
-                ret = av_dict_set(&c->avio_opts, *opt, buf, AV_DICT_DONT_STRDUP_VAL);
+            if (buf != NULL && buf[0] != '\0') {
+                ret = av_dict_set(&c->avio_opts, *opt, buf,
+                                  AV_DICT_DONT_STRDUP_VAL);
                 if (ret < 0) {
                     av_freep(&buf);
                     return ret;
@@ -1501,27 +1673,33 @@ static int reopen_demux_for_component(AVFormatContext *s, struct representation
         /* note: the internal buffer could have changed, and be != avio_ctx_buffer */
         av_freep(&pls->pb.buffer);
         memset(&pls->pb, 0x00, sizeof(AVIOContext));
+
         pls->ctx->pb = NULL;
         avformat_close_input(&pls->ctx);
         pls->ctx = NULL;
     }
+
     if (!(pls->ctx = avformat_alloc_context())) {
         ret = AVERROR(ENOMEM);
         goto fail;
     }
 
     avio_ctx_buffer  = av_malloc(INITIAL_BUFFER_SIZE);
-    if (!avio_ctx_buffer ) {
+    if (!avio_ctx_buffer ){
         ret = AVERROR(ENOMEM);
         avformat_free_context(pls->ctx);
         pls->ctx = NULL;
         goto fail;
     }
+
     if (c->is_live) {
-        ffio_init_context(&pls->pb, avio_ctx_buffer , INITIAL_BUFFER_SIZE, 0, pls, read_data, NULL, NULL);
+        ffio_init_context(&pls->pb, avio_ctx_buffer , INITIAL_BUFFER_SIZE, 0, pls,
+                          read_data, NULL, NULL);
     } else {
-        ffio_init_context(&pls->pb, avio_ctx_buffer , INITIAL_BUFFER_SIZE, 0, pls, read_data, NULL, seek_data);
+        ffio_init_context(&pls->pb, avio_ctx_buffer , INITIAL_BUFFER_SIZE, 0, pls,
+                  read_data, NULL, seek_data);
     }
+
     pls->pb.seekable = 0;
 
     if ((ret = ff_copy_whiteblacklists(pls->ctx, s)) < 0)
@@ -1529,29 +1707,42 @@ static int reopen_demux_for_component(AVFormatContext *s, struct representation
 
     pls->ctx->flags = AVFMT_FLAG_CUSTOM_IO;
     pls->ctx->probesize = 1024 * 4;
-    pls->ctx->max_analyze_duration = 4 * AV_TIME_BASE;
-    ret = av_probe_input_buffer(&pls->pb, &in_fmt, "", NULL, 0, 0);
+    pls->ctx->max_analyze_duration = 4 * AV_TIME_BASE; 
+    /////////////////
+#if 1
+    ret = av_probe_input_buffer(&pls->pb, &in_fmt, "",
+                                NULL, 0, 0);
     if (ret < 0) {
-        av_log(s, AV_LOG_ERROR, "Error when loading first fragment, playlist %d\n", (int)pls->rep_idx);
+        av_log(s, AV_LOG_ERROR, "Error when loading first segment, playlist %d\n", (int)pls->rep_idx);
         avformat_free_context(pls->ctx);
         pls->ctx = NULL;
         goto fail;
     }
+#else
+    in_fmt = av_find_input_format("mp4");
+#endif
 
     pls->ctx->pb = &pls->pb;
     pls->ctx->io_open  = nested_io_open;
+    ////////////////////
 
     // provide additional information from mpd if available
+    // av_dict_set(&in_fmt_opts, "video_size", "640x480", 0);
+    // av_dict_set(&in_fmt_opts, "pixel_format", "rgb24", 0);
     ret = avformat_open_input(&pls->ctx, "", in_fmt, &in_fmt_opts); //pls->init_section->url
     av_dict_free(&in_fmt_opts);
     if (ret < 0)
         goto fail;
-    if (pls->n_fragments) {
+
+    if (pls->n_segments == 1) {
+        //pls->ctx->ctx_flags &= ~AVFMTCTX_NOHEADER;
         ret = avformat_find_stream_info(pls->ctx, NULL);
         if (ret < 0)
             goto fail;
     }
 
+    av_log(pls->parent, AV_LOG_VERBOSE, "%s nb_streams[%d]\n", __FUNCTION__, (int)pls->ctx->nb_streams);
+
 fail:
     return ret;
 }
@@ -1562,13 +1753,14 @@ static int open_demux_for_component(AVFormatContext *s, struct representation *p
     int i;
 
     pls->parent = s;
-    pls->cur_seq_no  = calc_cur_seg_no(s, pls);
+    pls->cur_seq_no  = calc_cur_seg_no(pls, s->priv_data);
     pls->last_seq_no = calc_max_seg_no(pls, s->priv_data);
 
     ret = reopen_demux_for_component(s, pls);
     if (ret < 0) {
         goto fail;
     }
+
     for (i = 0; i < pls->ctx->nb_streams; i++) {
         AVStream *st = avformat_new_stream(s, NULL);
         AVStream *ist = pls->ctx->streams[i];
@@ -1577,6 +1769,8 @@ static int open_demux_for_component(AVFormatContext *s, struct representation *p
             goto fail;
         }
         st->id = i;
+
+        // avcodec_copy_context(st->codec, pls->ctx->streams[i]->codec);
         avcodec_parameters_copy(st->codecpar, pls->ctx->streams[i]->codecpar);
         avpriv_set_pts_info(st, ist->pts_wrap_bits, ist->time_base.num, ist->time_base.den);
     }
@@ -1594,6 +1788,7 @@ static int dash_read_header(AVFormatContext *s)
     int stream_index = 0;
 
     c->interrupt_callback = &s->interrupt_callback;
+
     // if the URL context is good, read important options we must broker later
     if (u) {
         update_options(&c->user_agent, "user-agent", u);
@@ -1601,7 +1796,7 @@ static int dash_read_header(AVFormatContext *s)
         update_options(&c->headers, "headers", u);
     }
 
-    if ((ret = parse_manifest(s, s->filename, s->pb)) < 0)
+    if ((ret = parse_mainifest(s, s->filename, s->pb)) < 0)
         goto fail;
 
     if ((ret = save_avio_options(s)) < 0)
@@ -1610,13 +1805,13 @@ static int dash_read_header(AVFormatContext *s)
     /* If this isn't a live stream, fill the total duration of the
      * stream. */
     if (!c->is_live) {
-        s->duration = (int64_t) c->media_presentation_duration * AV_TIME_BASE;
+        s->duration = (int64_t) c->mediaPresentationDurationSec * AV_TIME_BASE;
     }
 
     /* Open the demuxer for curent video and current audio components if available */
-    if (!ret && c->cur_video) {
+    if (0 == ret && c->cur_video) {
         ret = open_demux_for_component(s, c->cur_video);
-        if (!ret) {
+        if (ret == 0) {
             c->cur_video->stream_index = stream_index;
             ++stream_index;
         } else {
@@ -1625,9 +1820,9 @@ static int dash_read_header(AVFormatContext *s)
         }
     }
 
-    if (!ret && c->cur_audio) {
+    if (0 == ret && c->cur_audio) {
         ret = open_demux_for_component(s, c->cur_audio);
-        if (!ret) {
+        if (ret == 0) {
             c->cur_audio->stream_index = stream_index;
             ++stream_index;
         } else {
@@ -1636,13 +1831,13 @@ static int dash_read_header(AVFormatContext *s)
         }
     }
 
-    if (!stream_index) {
+    if (0 == stream_index) {
         ret = AVERROR_INVALIDDATA;
         goto fail;
     }
 
     /* Create a program */
-    if (!ret) {
+    if (0 == ret) {
         AVProgram *program;
         program = av_new_program(s, 0);
         if (!program) {
@@ -1652,6 +1847,7 @@ static int dash_read_header(AVFormatContext *s)
         if (c->cur_video) {
             av_program_add_stream_index(s, 0, c->cur_video->stream_index);
         }
+
         if (c->cur_audio) {
             av_program_add_stream_index(s, 0, c->cur_audio->stream_index);
         }
@@ -1668,48 +1864,64 @@ static int dash_read_packet(AVFormatContext *s, AVPacket *pkt)
     int ret = 0;
     struct representation *cur = NULL;
 
-    if (!c->cur_audio && !c->cur_video ) {
+    if (!c->cur_audio && !c->cur_video) {
         return AVERROR_INVALIDDATA;
     }
+
     if (c->cur_audio && !c->cur_video) {
         cur = c->cur_audio;
     } else if (!c->cur_audio && c->cur_video) {
         cur = c->cur_video;
-    } else if (c->cur_video->cur_timestamp < c->cur_audio->cur_timestamp) {
-        cur = c->cur_video;
-    } else {
+    } else if (c->cur_video->cur_timestamp > c->cur_audio->cur_timestamp) {
         cur = c->cur_audio;
+    } else {
+        cur = c->cur_video;
     }
 
     if (cur->ctx) {
-        while (!ff_check_interrupt(c->interrupt_callback) && !ret) {
-            ret = av_read_frame(cur->ctx, pkt);
-            if (ret >= 0) {
+        while (!ff_check_interrupt(c->interrupt_callback) && ret == 0) {
+            ret = av_read_frame(cur->ctx, &cur->pkt);
+
+            if (0 == ret) {
                 /* If we got a packet, return it */
+                *pkt = cur->pkt;
                 cur->cur_timestamp = av_rescale(pkt->pts, (int64_t)cur->ctx->streams[0]->time_base.num * 90000, cur->ctx->streams[0]->time_base.den);
                 pkt->stream_index = cur->stream_index;
+                reset_packet(&cur->pkt);
                 return 0;
             }
+
+            reset_packet(&cur->pkt);
+
             if (cur->is_restart_needed) {
-                cur->cur_seg_offset = 0;
-                cur->init_sec_buf_read_offset = 0;
-                if (cur->input)
-                    ff_format_io_close(cur->parent, &cur->input);
-                ret = reopen_demux_for_component(s, cur);
+                while (!ff_check_interrupt(c->interrupt_callback)) {
+                    cur->cur_seg_offset = 0;
+                    cur->init_sec_buf_read_offset = 0;
+                    if (cur->input)
+                        ff_format_io_close(cur->parent, &cur->input);
+                    ret = reopen_demux_for_component(s, cur);
+                    if (c->is_live && ret != 0) {
+                        sleep(2);
+                        continue;
+                    }
+                    break;
+                }
                 cur->is_restart_needed = 0;
             }
-
         }
     }
+
     return AVERROR_EOF;
 }
 
 static int dash_close(AVFormatContext *s)
 {
     DASHContext *c = s->priv_data;
+
     if (c->cur_audio) {
         free_representation(c->cur_audio);
     }
+
     if (c->cur_video) {
         free_representation(c->cur_video);
     }
@@ -1721,100 +1933,105 @@ static int dash_close(AVFormatContext *s)
     return 0;
 }
 
-static int dash_seek(AVFormatContext *s, struct representation *pls, int64_t seek_pos_msec, int flags)
+static int dash_seek(AVFormatContext *s, struct representation *pls, int64_t seekPosMSec, int flags)
 {
     int ret = 0;
-    int i = 0;
-    int j = 0;
-    int64_t duration = 0;
 
-    av_log(pls->parent, AV_LOG_VERBOSE, "DASH seek pos[%"PRId64"ms], playlist %d\n", seek_pos_msec, pls->rep_idx);
-
-    // single fragment mode
-    if (pls->n_fragments == 1) {
+    av_log(pls->parent, AV_LOG_VERBOSE, "DASH seek pos[%"PRId64"ms], playlist %d\n", seekPosMSec, pls->rep_idx);
+    // single segment mode
+    if (pls->n_segments == 1) {
         pls->cur_timestamp = 0;
         pls->cur_seg_offset = 0;
         ff_read_frame_flush(pls->ctx);
-        return av_seek_frame(pls->ctx, -1, seek_pos_msec * 1000, flags);
+        return av_seek_frame(pls->ctx, -1, seekPosMSec*1000, flags);
     }
 
     if (pls->input)
         ff_format_io_close(pls->parent, &pls->input);
 
-    // find the nearest fragment
-    if (pls->n_timelines > 0 && pls->fragment_timescale > 0) {
+    // find the nearest segment
+    if (pls->n_timelines > 0 && pls->segmentTimescalce > 0) {
+        int64_t duration = 0;
+        int i;
+        int j;
         int64_t num = pls->first_seq_no;
-        av_log(pls->parent, AV_LOG_VERBOSE, "dash_seek with SegmentTimeline start n_timelines[%d] "
-               "last_seq_no[%"PRId64"], playlist %d.\n",
-               (int)pls->n_timelines, (int64_t)pls->last_seq_no, (int)pls->rep_idx);
-        for (i = 0; i < pls->n_timelines; i++) {
-            if (pls->timelines[i]->starttime > 0) {
-                duration = pls->timelines[i]->starttime;
+        av_log(pls->parent, AV_LOG_VERBOSE, "dash_seek with SegmentTimeline start n_timelines[%d] last_seq_no[%"PRId64"], playlist %d.\n", (int)pls->n_timelines, (int64_t)pls->last_seq_no, (int)pls->rep_idx);
+        for (i = 0; i < pls->n_timelines; ++i) {
+            if (pls->timelines[i]->t > 0) {
+                duration = pls->timelines[i]->t;
             }
-            duration += pls->timelines[i]->duration;
-            if (seek_pos_msec < ((duration * 1000) /  pls->fragment_timescale)) {
+
+            duration += pls->timelines[i]->d;
+            if (seekPosMSec < ((duration * 1000) /  pls->segmentTimescalce)) {
                 goto set_seq_num;
             }
-            for (j = 0; j < pls->timelines[i]->repeat; j++) {
-                duration += pls->timelines[i]->duration;
-                num++;
-                if (seek_pos_msec < ((duration * 1000) /  pls->fragment_timescale)) {
+
+            for (j = 0; j < pls->timelines[i]->r; ++j) {
+                duration += pls->timelines[i]->d;
+                num += 1;
+                if (seekPosMSec < ((duration * 1000) /  pls->segmentTimescalce)) {
                     goto set_seq_num;
                 }
             }
-            num++;
+            num += 1;
         }
-
 set_seq_num:
         pls->cur_seq_no = num > pls->last_seq_no ? pls->last_seq_no : num;
-        av_log(pls->parent, AV_LOG_VERBOSE, "dash_seek with SegmentTimeline end cur_seq_no[%"PRId64"], playlist %d.\n",
-               (int64_t)pls->cur_seq_no, (int)pls->rep_idx);
-    } else if (pls->fragment_duration > 0) {
-        pls->cur_seq_no = pls->first_seq_no + ((seek_pos_msec * pls->fragment_timescale) / pls->fragment_duration) / 1000;
+        av_log(pls->parent, AV_LOG_VERBOSE, "dash_seek with SegmentTimeline end cur_seq_no[%"PRId64"], playlist %d.\n", (int64_t)pls->cur_seq_no, (int)pls->rep_idx);
+    }
+    else if(pls->segmentDuration > 0) {
+        pls->cur_seq_no = pls->first_seq_no + ((seekPosMSec * pls->segmentTimescalce) / pls->segmentDuration) / 1000;
     } else {
-        av_log(pls->parent, AV_LOG_ERROR, "dash_seek missing fragment_duration\n");
+        av_log(pls->parent, AV_LOG_ERROR, "dash_seek missing segmentDuration\n");
         pls->cur_seq_no = pls->first_seq_no;
     }
     pls->cur_timestamp = 0;
     pls->cur_seg_offset = 0;
+
     pls->init_sec_buf_read_offset = 0;
     ret = reopen_demux_for_component(s, pls);
 
     return ret;
 }
 
-static int dash_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
+static int dash_read_seek(AVFormatContext *s, int stream_index,
+                               int64_t timestamp, int flags)
 {
     int ret = 0;
     DASHContext *c = s->priv_data;
-    int64_t seek_pos_msec = av_rescale_rnd(timestamp, 1000,
-                                           s->streams[stream_index]->time_base.den,
-                                           flags & AVSEEK_FLAG_BACKWARD ?
-                                           AV_ROUND_DOWN : AV_ROUND_UP);
+    int64_t seekPosMSec = av_rescale_rnd(timestamp, 1000,
+                            s->streams[stream_index]->time_base.den,
+                            flags & AVSEEK_FLAG_BACKWARD ?
+                            AV_ROUND_DOWN : AV_ROUND_UP);
+
     if ((flags & AVSEEK_FLAG_BYTE) || c->is_live)
         return AVERROR(ENOSYS);
+
     if (c->cur_audio) {
-        ret = dash_seek(s, c->cur_audio, seek_pos_msec, flags);
+        ret = dash_seek(s, c->cur_audio, seekPosMSec, flags);
     }
-    if (!ret && c->cur_video) {
-        ret = dash_seek(s, c->cur_video, seek_pos_msec, flags);
+
+    if (0 == ret && c->cur_video) {
+        ret = dash_seek(s, c->cur_video, seekPosMSec, flags);
     }
+
     return ret;
 }
 
 static int dash_probe(AVProbeData *p)
 {
-    if (!av_stristr(p->buf, "<MPD"))
+    if (!strstr(p->buf, "<MPD"))
         return 0;
 
-    if (av_stristr(p->buf, "dash:profile:isoff-on-demand:2011") ||
-        av_stristr(p->buf, "dash:profile:isoff-live:2011") ||
-        av_stristr(p->buf, "dash:profile:isoff-live:2012") ||
-        av_stristr(p->buf, "dash:profile:isoff-main:2011")) {
+    if (strstr(p->buf, "dash:profile:isoff-on-demand:2011") ||
+        strstr(p->buf, "dash:profile:isoff-live:2011") ||
+        strstr(p->buf, "dash:profile:isoff-live:2012") ||
+        strstr(p->buf, "dash:profile:isoff-main:2011")) {
         return AVPROBE_SCORE_MAX;
     }
-    if (av_stristr(p->buf, "dash:profile")) {
-        return AVPROBE_SCORE_MAX;
+
+    if (strstr(p->buf, "dash:profile")) {
+        return AVPROBE_SCORE_MAX / 2;
     }
 
     return 0;
@@ -1823,10 +2040,10 @@ static int dash_probe(AVProbeData *p)
 #define OFFSET(x) offsetof(DASHContext, x)
 #define FLAGS AV_OPT_FLAG_DECODING_PARAM
 static const AVOption dash_options[] = {
-    {"allowed_extensions", "List of file extensions that dash is allowed to access",
-        OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,
-        {.str = "aac,m4a,m4s,m4v,mov,mp4"},
-        INT_MIN, INT_MAX, FLAGS},
+    {"audio_rep_index", "audio representation index to be used",
+        OFFSET(audio_rep_index), AV_OPT_TYPE_INT, {.i64 = -1}, INT_MIN, INT_MAX, FLAGS},
+    {"video_rep_index", "video representation index to be used",
+        OFFSET(video_rep_index), AV_OPT_TYPE_INT, {.i64 = -1}, INT_MIN, INT_MAX, FLAGS},
     {NULL}
 }; 
